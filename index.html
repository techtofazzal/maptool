<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Noksha Tool by Tofazzal</title> <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent body scroll */
            background-color: #f8fafc; /* Overall light background */
        }
        #toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px; /* Reduced gap for smaller buttons */
            padding: 8px; /* Reduced padding for smaller buttons */
            background: linear-gradient(to right, #ffffff, #f0f4f8); /* Subtle gradient for toolbar */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* More prominent shadow for toolbar */
            z-index: 10;
            border-bottom-left-radius: 12px; /* Rounded bottom corners */
            border-bottom-right-radius: 12px;
        }
        #toolbar button,
        #toolbar input[type="file"] {
            padding: 6px 12px; /* Reduced padding for smaller buttons */
            font-size: 0.8rem; /* Smaller font */
            border-radius: 9999px; /* Full rounded corners */
            box-shadow: 0 3px 6px rgba(0,0,0,0.12); /* Softer, more diffused shadow */
            transition: all 0.3s ease-in-out;
            border: 1px solid rgba(0,0,0,0.08); /* Subtle border for definition */
            background-image: linear-gradient(to bottom, var(--tw-gradient-from), var(--tw-gradient-to)); /* For Tailwind colors with gradients */
        }
        /* Define common button styles using Tailwind placeholders for custom gradients */
        #toolbar button.bg-blue-500 { --tw-gradient-from: #3b82f6; --tw-gradient-to: #2563eb; } /* Blue-500 to Blue-600 */
        #toolbar button.bg-green-500 { --tw-gradient-from: #22c55e; --tw-gradient-to: #16a34a; } /* Green-500 to Green-600 */
        #toolbar button.bg-purple-500 { --tw-gradient-from: #a855f7; --tw-gradient-to: #9333ea; } /* Purple-500 to Purple-600 */
        #toolbar button.bg-indigo-500 { --tw-gradient-from: #6366f1; --tw-gradient-to: #4f46e5; } /* Indigo-500 to Indigo-600 */
        #toolbar button.bg-pink-500 { --tw-gradient-from: #ec4899; --tw-gradient-to: #db2777; } /* Pink-500 to Pink-600 */
        #toolbar button.bg-orange-500 { --tw-gradient-from: #f97316; --tw-gradient-to: #ea580c; } /* Orange-500 to Orange-600 */
        #toolbar button.bg-teal-500 { --tw-gradient-from: #14b8a6; --tw-gradient-to: #0d9488; } /* Teal-500 to Teal-600 */
        #toolbar button.bg-cyan-500 { --tw-gradient-from: #06b6d4; --tw-gradient-to: #0891b2; } /* Cyan-500 to Cyan-600 */
        #toolbar button.bg-gray-500 { --tw-gradient-from: #6b7280; --tw-gradient-to: #4b5563; } /* Gray-500 to Gray-600 */
        #toolbar button.bg-gray-600 { --tw-gradient-from: #4b5563; --tw-gradient-to: #374151; } /* Gray-600 to Gray-700 for export */
        #toolbar button.bg-yellow-500 { --tw-gradient-from: #f59e0b; --tw-gradient-to: #d97706; } /* Yellow-500 to Yellow-600 */
        #toolbar button.bg-red-500 { --tw-gradient-from: #ef4444; --tw-gradient-to: #dc2626; } /* Red-500 to Red-600 */
        #toolbar button.bg-angle-snap { --tw-gradient-from: #60a5fa; --tw-gradient-to: #3b82f6; } /* Blue-400 to Blue-500 for angle snap */


        #toolbar button:hover {
            transform: translateY(-2px); /* More noticeable lift on hover */
            box-shadow: 0 6px 12px rgba(0,0,0,0.2); /* Stronger shadow on hover */
            filter: brightness(1.1); /* Slightly brighter on hover */
        }
        #toolbar label input[type="number"],
        #toolbar label input[type="range"],
        #toolbar label input[type="color"],
        #toolbar label select {
            padding: 5px 8px; /* Further reduced padding for inputs */
            font-size: 0.8rem; /* Smaller font for inputs */
            border-radius: 8px; /* Rounded corners for inputs */
            background-color: #e2e8f0; /* Tailwind gray-200 */
            border: 1px solid #94a3b8; /* Darker border for inputs */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.08); /* More defined inset shadow */
        }
        #main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #canvas-container {
            position: relative;
            flex-grow: 1;
            background: #e2e8f0; /* Tailwind gray-200 */
            overflow: hidden;
            touch-action: none; /* Disable default touch actions for custom handling */
            cursor: default; /* Default cursor for pan mode */
            transition: all 0.2s ease-in-out;
        }
        #canvas-container.drawing-mode {
            cursor: crosshair; /* Crosshair cursor for drawing modes */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #f8fafc; /* Tailwind gray-50 */
            touch-action: none;
        }
        .magnifier {
            position: absolute;
            top: 10px; /* Fixed position from top */
            left: 10px; /* Fixed position from left */
            width: 200px; /* Increased size */
            height: 200px; /* Increased size */
            border: 2px solid #3b82f6; /* Blue-500 */
            border-radius: 8px; /* Rounded corners */
            overflow: hidden;
            pointer-events: none; /* Allow events to pass through */
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); /* Soft shadow */
            background-color: white; /* Fallback for transparency */
            display: none; /* Hidden by default */
        }
        #measurements-sidebar {
            width: 300px;
            background: #f1f5f9; /* Tailwind gray-100 */
            padding: 10px;
            overflow-y: auto;
            box-shadow: -2px 0 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 8px; /* Increased gap in sidebar */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            transition: width 0.3s ease-in-out, padding 0.3s ease-in-out; /* Smooth transition for collapse */
        }

        /* Collapsed state for sidebar */
        #measurements-sidebar.collapsed {
            width: 50px; /* Reduced width when collapsed */
            padding: 10px 5px; /* Reduced padding */
            overflow: hidden; /* Hide scrollbar and content */
        }

        #measurements-sidebar .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px; /* Space between header and list */
        }

        #measurements-sidebar.collapsed .sidebar-header {
            justify-content: center; /* Center arrow when collapsed */
            margin-bottom: 0;
        }

        #measurements-sidebar.collapsed .sidebar-content {
            display: none; /* Hide content when collapsed */
        }

        #measurements-sidebar .toggle-sidebar-btn {
            background: none;
            border: none;
            font-size: 1.5rem; /* Larger arrow icon */
            cursor: pointer;
            color: #475569; /* Slate-600 */
            padding: 0;
            line-height: 1; /* Adjust line height for better vertical alignment */
            transition: transform 0.3s ease-in-out;
        }

        #measurements-sidebar.collapsed .toggle-sidebar-btn {
            transform: rotate(180deg); /* Rotate arrow when collapsed */
        }

        .measurement-item {
            background: white;
            padding: 10px; /* Increased padding */
            border-radius: 8px; /* More rounded corners */
            box-shadow: 0 2px 4px rgba(0,0,0,0.08); /* Softer item shadow */
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem; /* Slightly larger text */
        }
        .measurement-item button {
            background: #ef4444; /* Red-500 */
            color: white;
            border: none;
            border-radius: 6px; /* More rounded delete button */
            padding: 6px 12px; /* Nicer padding */
            cursor: pointer;
            font-size: 0.75rem;
            transition: background-color 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08); /* Small shadow on delete button */
        }
        .measurement-item button.edit-btn {
            background: #22c55e; /* Green-500 for edit button */
            margin-left: 5px; /* Add some space between delete and edit */
        }
        .measurement-item button:hover {
            background: #dc2626; /* Red-600 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* Slightly larger shadow on hover */
        }
        .measurement-item button.edit-btn:hover {
            background: #16a34a; /* Green-600 for edit button hover */
        }
        #output {
            padding: 12px; /* Increased padding */
            background: linear-gradient(to right, #ffffff, #f0f4f8); /* Subtle gradient */
            text-align: center;
            box-shadow: 0 -4px 8px rgba(0,0,0,0.15); /* More prominent shadow */
            z-index: 10;
            font-weight: 500; /* Medium font weight */
            color: #334155; /* Slate-700 */
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        .modal-content h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1e293b; /* Slate-800 */
        }

        .modal-content .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-content .modal-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .modal-content .modal-buttons button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .modal-content .modal-buttons .btn-primary {
            background-color: #3b82f6; /* Blue-500 */
            color: white;
        }
        .modal-content .modal-buttons .btn-primary:hover {
            background-color: #2563eb; /* Blue-600 */
        }

        .modal-content .modal-buttons .btn-secondary {
            background-color: #e2e8f0; /* Gray-200 */
            color: #334155; /* Slate-700 */
            border: 1px solid #cbd5e1; /* Gray-300 */
        }
        .modal-content .modal-buttons .btn-secondary:hover {
            background-color: #cbd5e1; /* Gray-300 */
        }
        /* WhatsApp Button specific styles */
        .whatsapp-button-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000; /* Ensure it's above other content */
        }
        .whatsapp-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 25px;
            background-color: #25d366;
            color: white;
            border: none; /* Remove border */
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            text-decoration: none;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(37, 211, 102, 0.3);
            cursor: pointer;
        }
        .whatsapp-button:hover {
            background-color: #1da851;
            transform: translateY(-2px);
        }
        .whatsapp-icon {
            margin-right: 10px;
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Load Image:
            <input
                type="file"
                id="imageLoader"
                accept="image/*, application/pdf"
                class="block w-full text-sm text-gray-500 file:mr-4 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"
            />
        </label>

        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Image DPI:
            <input type="number" id="dpiInput" value="400" class="w-20" />
        </label>

        <button
            id="calibrateScaleBtn"
            class="bg-blue-500 text-white hover:bg-blue-600 transition-colors duration-200"
        >
            Calibrate
        </button>

        <button
            id="confirmCalibrationBtn"
            class="bg-green-500 text-white hover:bg-green-600 transition-colors duration-200"
            style="display: none;"
        >
            Confirm
        </button>

        <button
            id="drawLineBtn"
            class="bg-green-500 text-white hover:bg-green-600 transition-colors duration-200"
        >
            Line
        </button>

        <button
            id="drawRectangleBtn"
            class="bg-purple-500 text-white hover:bg-purple-600 transition-colors duration-200"
        >
            Rectangle
        </button>

        <button
            id="drawPolygonBtn"
            class="bg-indigo-500 text-white hover:bg-indigo-600 transition-colors duration-200"
        >
            Polygon
        </button>

        <button
            id="drawAngleBtn"
            class="bg-pink-500 text-white hover:bg-pink-600 transition-colors duration-200"
        >
            Angle
        </button>

        <button
            id="drawCircleBtn"
            class="bg-orange-500 text-white hover:bg-orange-600 transition-colors duration-200"
        >
            Circle
        </button>

        <button
            id="addTextBtn"
            class="bg-teal-500 text-white hover:bg-teal-600 transition-colors duration-200"
        >
            Text
        </button>

        <div class="relative">
            <button id="scaleButton" class="bg-blue-500 text-white hover:bg-blue-600 transition-colors duration-200">
                Scale: 16 inch = 1 mile
            </button>
            <div id="scaleDropdown" class="absolute hidden bg-white shadow-lg rounded-md mt-1 z-20">
                <button data-scale="16inch=1mile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md">16 inch = 1 mile</button>
                <button data-scale="32inch=1mile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md">32 inch = 1 mile</button>
                <button data-scale="48inch=1mile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md">48 inch = 1 mile</button> <button data-scale="64inch=1mile" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md">64 inch = 1 mile</button>
            </div>
        </div>

       

        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Line Width:
            <input type="range" id="lineWidthInput" min="1" max="10" value="2" class="w-20" />
        </label>
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Font Size:
            <input type="range" id="fontSizeInput" min="10" max="30" value="14" class="w-20" />
        </label>
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Color:
            <input type="color" id="colorPicker" value="#FF0000" class="w-12 h-8 rounded-md border border-gray-300 cursor-pointer" />
        </label>
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Line Style:
            <select id="lineStyleSelect" class="px-2 py-1 rounded-md text-sm bg-gray-200">
                <option value="solid">Solid</option>
                <option value="dashed">Dashed</option>
            </select>
        </label>

        <button
            id="exportBtn"
            class="bg-gray-600 text-white hover:bg-gray-700 transition-colors duration-200"
        >
            Export
        </button>

        <button
            id="undoBtn"
            class="bg-yellow-500 text-white hover:bg-yellow-600 transition-colors duration-200"
            disabled
        >
            Undo
        </button>
        <button
            id="redoBtn"
            class="bg-yellow-500 text-white hover:bg-yellow-600 transition-colors duration-200"
            disabled
        >
            Redo
        </button>

        <button
            id="resetAllBtn"
            class="bg-red-500 text-white hover:bg-red-600 transition-colors duration-200"
        >
            Reset
        </button>
    </div>

    <div id="main-content">
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <div id="magnifier" class="magnifier">
                <canvas id="magnifierCanvas"></canvas>
            </div>
        </div>

        <div id="measurements-sidebar">
            <div class="sidebar-header">
                <h3 class="text-lg font-bold">Current Measurements</h3>
                <button id="toggleSidebarBtn" class="toggle-sidebar-btn">
                    &#x25BA; </button>
            </div>
            <div id="measurementsList" class="flex flex-col gap-2 sidebar-content">
                </div>
        </div>
    </div>

    <div id="output">
        Load an image or PDF and start measuring.
    </div>

    <div id="exportModal" class="modal-overlay">
        <div class="modal-content">
            <h4>Export Options</h4>
            <p>Choose your desired export format:</p>
            <div class="modal-buttons">
                <button id="exportCsvOptionBtn" class="btn-secondary">Export as CSV</button>
                <button id="exportPngOptionBtn" class="btn-primary">Export as PNG</button>
            </div>
        </div>
    </div>

    <div class="whatsapp-button-container">
        <button class="whatsapp-button" id="whatsappContact">
            <svg class="whatsapp-icon" viewBox="0 0 24 24">
                <path d="M12.04 2C7.34 2 3.5 5.8 3.5 10.5C3.5 12.1 4 13.6 4.8 14.9L3.2 21.7L10.14 20.2C11.4 20.8 12.7 21.1 14.1 21.1C18.8 21.1 22.6 17.3 22.6 12.6C22.6 7.9 18.8 4 14.1 4C13.4 4 12.7 4.1 12.04 4.2C7.34 4.2 3.5 8 3.5 12.7C3.5 14.3 4 15.8 4.8 17.1L3.2 23.9L10.14 22.4C11.4 23 12.7 23.3 14.1 23.3C18.8 23.3 22.6 19.5 22.6 14.8C22.6 10.1 18.8 6.2 14.1 6.2C13.4 6.2 12.7 6.3 12.04 6.4L12.04 2ZM12.04 4.2C12.7 4.1 13.4 4 14.1 4C18.8 4 22.6 7.9 22.6 12.6C22.6 17.3 18.8 21.1 14.1 21.1C12.7 21.1 11.4 20.8 10.14 20.2L3.2 21.7L4.8 14.9C4 13.6 3.5 12.1 3.5 10.5C3.5 5.8 7.34 2 12.04 2Z" fill="currentColor"/>
            </svg>
            WhatsApp এ যোগাযোগ করুন
        </button>
    </div>

    <script>
        // Set up PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Get references to HTML elements
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        const imageLoader = document.getElementById('imageLoader');
        const drawLineBtn = document.getElementById('drawLineBtn');
        const drawRectangleBtn = document.getElementById('drawRectangleBtn');
        const drawPolygonBtn = document.getElementById('drawPolygonBtn');
        const drawAngleBtn = document.getElementById('drawAngleBtn');
        const drawCircleBtn = document.getElementById('drawCircleBtn');
        const addTextBtn = document.getElementById('addTextBtn');
        const exportBtn = document.getElementById('exportBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const resetAllBtn = document.getElementById('resetAllBtn');
        const outputDisplay = document.getElementById('output');
        const magnifierDiv = document.getElementById('magnifier');
        const magnifierCanvas = document.getElementById('magnifierCanvas');
        const magnifyCtx = magnifierCanvas.getContext('2d');
        const measurementsListDiv = document.getElementById('measurementsList');
        const canvasContainer = document.getElementById('canvas-container');
        const calibrateScaleBtn = document.getElementById('calibrateScaleBtn');
        const confirmCalibrationBtn = document.getElementById('confirmCalibrationBtn');
        const measurementsSidebar = document.getElementById('measurements-sidebar');
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');

        // New Scale elements
        const scaleButton = document.getElementById('scaleButton');
        const scaleDropdown = document.getElementById('scaleDropdown');


        const lineWidthInput = document.getElementById('lineWidthInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const colorPicker = document.getElementById('colorPicker');
        const lineStyleSelect = document.getElementById('lineStyleSelect');

        // Modal elements
        const exportModal = document.getElementById('exportModal');
        const exportCsvOptionBtn = document.getElementById('exportCsvOptionBtn');
        const exportPngOptionBtn = document.getElementById('exportPngOptionBtn');

        // Global state variables
        let img = new Image();
        let imgLoaded = false;
        let zoom = 1;
        let pan = { x: 0, y: 0 };
        let isDragging = false;
        let startPoint = { x: 0, y: 0 };
        let currentDrawing = null;
        let selectedPoint = null; // Stores info about a point being dragged/edited { measurementIndex, pointIndex, type }
        let mode = 'pan';
        let measurements = [];
        let counterValue = 1; // Kept for text/csv export compatibility, though counter button removed
        let snappedToPoint = null; // Stores the {x, y} of the point currently being snapped to, for visual feedback

        let currentColor = colorPicker.value; // Initialize with default color picker value
        let currentLineStyle = lineStyleSelect.value; // Initialize with default line style value

        // DPI and Scale variables
        let currentDpi = 400; // Changed from const to let, renamed for clarity
        let FEET_PER_INCH_CURRENT; // This will be set by scale selection
        let scaleFactorPixelsPerUnit;

        // Default scale setting
        let currentScaleSetting = '16inch=1mile';

        // History for Undo/Redo
        let measurementHistory = [];
        let historyPointer = -1;

        const unit = 'ft';

        const HIT_RADIUS_BASE = 10;
        const SNAP_RADIUS = 3;
        const MAGNIFIER_SIZE = 25;
        const MAGNIFIER_ZOOM = 0.25;


        // Get device pixel ratio for high-DPI screens (e.g., Retina displays)
        const dpr = window.devicePixelRatio || 1;

        // Set magnifier canvas size, adjusting for device pixel ratio for clarity
        magnifierCanvas.width = MAGNIFIER_SIZE * dpr;
        magnifierCanvas.height = MAGNIFIER_SIZE * dpr;
        magnifyCtx.scale(dpr, dpr);

        /**
         * Helper: Converts screen coordinates (from a mouse/touch event) to canvas coordinates.
         * Accounts for the canvas's position on the screen, current pan, and zoom level.
         * @param {number} clientX - The clientX coordinate from a pointer event.
         * @param {number} clientY - The clientY coordinate from a pointer event.
         * @returns {{x: number, y: number}} The corresponding canvas coordinates.
         */
        function getCanvasCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            const x = (clientX - rect.left - pan.x) / zoom;
            const y = (clientY - rect.top - pan.y) / zoom;
            return { x, y };
        }

        /**
         * Helper: Converts canvas coordinates to screen coordinates.
         * Used to draw points or text at their correct screen positions after pan/zoom.
         * @param {number} x - The canvas X coordinate.
         * @param {number} y - The canvas Y coordinate.
         * @returns {{x: number, y: number}} The corresponding screen coordinates (relative to canvas top-left).
         */
        function getScreenCoords(x, y) {
            const screenX = x * zoom + pan.x;
            const screenY = y * zoom + pan.y;
            return { x: screenX, y: screenY };
        }

        /**
         * Calculates the intersection point of two line segments.
         * Returns null if segments are parallel or do not intersect within their bounds.
         * @param {{p1: {x: number, y: number}, p2: {x: number, y: number}}} segment1
         * @param {{p1: {x: number, y: number}, p2: {x: number, y: number}}} segment2
         * @returns {{x: number, y: number}|null} Intersection point or null.
         */
        function getSegmentIntersection(segment1, segment2) {
            const A = segment1.p1;
            const B = segment1.p2;
            const C = segment2.p1;
            const D = segment2.p2;

            const denom = (A.x - B.x) * (C.y - D.y) - (A.y - B.y) * (C.x - D.x);
            if (denom === 0) {
                return null; // Parallel or collinear
            }

            const t = ((A.x - C.x) * (C.y - D.y) - (A.y - C.y) * (C.x - D.x)) / denom;
            const u = -((A.x - B.x) * (A.y - C.y) - (A.y - B.y) * (A.x - C.x)) / denom;

            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: A.x + t * (B.x - A.x),
                    y: A.y + t * (B.y - A.y)
                };
            }
            return null; // No intersection within segments
        }


        /**
         * Helper: Gets canvas coordinates, potentially snapping to existing nearby points, midpoints, or intersections.
         * This creates a "magnetic" effect when drawing near existing measurement features.
         * @param {number} clientX - The clientX coordinate from a pointer event.
         * @param {number} clientY - The clientY coordinate from a pointer event.
         * @returns {{x: number, y: number}} The snapped or original canvas coordinates.
         */
        function getSnappedCanvasCoords(clientX, clientY) {
            let { x, y } = getCanvasCoords(clientX, clientY);
            snappedToPoint = null; // Reset snapped point for each check

            const currentScreenX = clientX;
            const currentScreenY = clientY;

            let allSnappableFeatures = []; // Stores points, midpoints, intersections

            // 1. Collect all existing measurement points
            measurements.forEach(m => {
                if (m.type !== 'text') { // Text has only one point, no need for complex snapping
                    m.points.forEach(p => allSnappableFeatures.push({ type: 'point', x: p.x, y: p.y }));
                }
            });

            // 2. Collect midpoints of all segments
            measurements.forEach(m => {
                let segments = [];
                if (m.type === 'line' || m.type === 'calibration') {
                    segments.push({ p1: m.points[0], p2: m.points[1] });
                } else if (m.type === 'rectangle') {
                    const [c1, c2, c3, c4] = m.points;
                    segments.push({ p1: c1, p2: c2 }, { p1: c2, p2: c3 }, { p1: c3, p2: c4 }, { p1: c4, p2: c1 });
                } else if (m.type === 'polygon' && m.closed) {
                    for (let i = 0; i < m.points.length; i++) {
                        segments.push({ p1: m.points[i], p2: m.points[(i + 1) % m.points.length] });
                    }
                } else if (m.type === 'angle' && m.points.length === 3) {
                    const [p1, p2, p3] = m.points;
                    segments.push({ p1: p1, p2: p2 }, { p1: p2, p2: p3 });
                } else if (m.type === 'circle' && m.points.length === 2) {
                    // For circles, we can add the center and cardinal points on the circumference as snappable points
                    const center = m.points[0];
                    const radius = Math.hypot(m.points[1].x - center.x, m.points[1].y - center.y);
                    allSnappableFeatures.push(
                        { type: 'point', x: center.x, y: center.y },
                        { type: 'point', x: center.x + radius, y: center.y },
                        { type: 'point', x: center.x - radius, y: center.y },
                        { type: 'point', x: center.x, y: center.y + radius },
                        { type: 'point', x: center.x, y: center.y - radius }
                    );
                }

                segments.forEach(seg => {
                    const midX = (seg.p1.x + seg.p2.x) / 2;
                    const midY = (seg.p1.y + seg.p2.y) / 2;
                    allSnappableFeatures.push({ type: 'midpoint', x: midX, y: midY });
                });
            });

            // 3. Collect intersection points of all segments
            const allSegments = [];
            measurements.forEach(m => {
                if (m.type === 'line' || m.type === 'calibration') {
                    allSegments.push({ p1: m.points[0], p2: m.points[1] });
                } else if (m.type === 'rectangle') {
                    const [c1, c2, c3, c4] = m.points;
                    allSegments.push({ p1: c1, p2: c2 }, { p1: c2, p2: c3 }, { p1: c3, p2: c4 }, { p1: c4, p2: c1 });
                } else if (m.type === 'polygon' && m.closed) {
                    for (let i = 0; i < m.points.length; i++) {
                        allSegments.push({ p1: m.points[i], p2: m.points[(i + 1) % m.points.length] });
                    }
                } else if (m.type === 'angle' && m.points.length === 3) {
                    const [p1, p2, p3] = m.points;
                    allSegments.push({ p1: p1, p2: p2 }, { p1: p2, p2: p3 });
                }
            });

            for (let i = 0; i < allSegments.length; i++) {
                for (let j = i + 1; j < allSegments.length; j++) {
                    const intersection = getSegmentIntersection(allSegments[i], allSegments[j]);
                    if (intersection) {
                        allSnappableFeatures.push({ type: 'intersection', x: intersection.x, y: intersection.y });
                    }
                }
            }


            // Prioritize snapping: existing points > midpoints > intersections
            // Sort by type to ensure priority, or iterate in order
            const prioritizedSnaps = ['point', 'midpoint', 'intersection'];
            let closestSnap = null;
            let minDistance = Infinity;

            for (const feature of allSnappableFeatures) {
                const screenP = getScreenCoords(feature.x, feature.y);
                const dist = Math.hypot(currentScreenX - (mainCanvas.getBoundingClientRect().left + screenP.x), currentScreenY - (mainCanvas.getBoundingClientRect().top + screenP.y));

                if (dist < SNAP_RADIUS && dist < minDistance) {
                    // Check priority: if current feature has higher priority or same priority but closer
                    if (!closestSnap || prioritizedSnaps.indexOf(feature.type) < prioritizedSnaps.indexOf(closestSnap.type) ||
                        (prioritizedSnaps.indexOf(feature.type) === prioritizedSnaps.indexOf(closestSnap.type) && dist < minDistance)) {
                        minDistance = dist;
                        closestSnap = feature;
                    }
                }
            }

            if (closestSnap) {
                x = closestSnap.x;
                y = closestSnap.y;
                snappedToPoint = closestSnap; // Store the snapped point for visual feedback
                return { x, y };
            }

            return { x, y };
        }


        /**
         * Helper: Draws a circle to represent a point on the canvas.
         * The radius scales with line width but not zoom, ensuring consistent visual size.
         * @param {CanvasRenderingContext2D} context - The canvas rendering context.
         * @param {number} x - The X coordinate of the point on the canvas.
         * @param {number} y - The Y coordinate of the point on the canvas.
         * @param {number} currentZoom - The current zoom level (unused for scaling here, but kept for consistency).
         */
        function drawPoint(context, x, y, currentZoom) {
            context.beginPath();
            // Point radius depends on lineWidthInput.value for visual consistency.
            // Ensure a minimum radius of 0.5 pixels for visibility
            const pointRadius = Math.max(0.5, parseFloat(lineWidthInput.value) * 1.5);
            context.arc(x, y, pointRadius, 0, Math.PI * 2);
            context.fillStyle = 'blue'; // Always draw points in blue
            context.fill();
        }

        /**
         * Helper: Draws an arrowhead at the end of a line.
         * @param {CanvasRenderingContext2D} context - The canvas rendering context.
         * @param {{x: number, y: number}} p1 - Start point of the line.
         * @param {{x: number, y: number}} p2 - End point of the line (where arrowhead is drawn).
         * @param {number} size - Size of the arrowhead.
         * @param {number} lineWidth - Current line width, for scaling the arrowhead.
         */
        function drawArrowhead(context, p1, p2, size, lineWidth) {
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            context.save();
            context.translate(p2.x, p2.y);
            context.rotate(angle);
            context.beginPath();
            // Arrowhead size scales with line width and zoom
            const arrowSize = size * (lineWidth / 2); // Base size * (current line width / default line width)
            context.moveTo(-arrowSize, -arrowSize / 2);
            context.lineTo(0, 0);
            context.lineTo(-arrowSize, arrowSize / 2);
            context.closePath(); // Close the path to fill it
            context.fill();
            context.restore();
        }

        /**
         * Helper: Sets the line style (e.g., solid, dashed) for the given context.
         * @param {CanvasRenderingContext2D} context - The canvas rendering context.
         * @param {string} style - 'solid' or 'dashed'.
         */
        function setLineStyle(context, style) {
            if (style === 'dashed') {
                context.setLineDash([10, 5]); // 10 pixels on, 5 pixels off
            } else {
                context.setLineDash([]); // Solid line
            }
        }

        /**
         * Calculates the real-world length of a line segment.
         * @param {{x: number, y: number}} p1 - Start point in canvas coordinates.
         * @param {{x: number, y: number}} p2 - End point in canvas coordinates.
         * @returns {string} Formatted length string in feet and links.
         */
        function calculateLineLength(p1, p2) {
            const lengthInPixels = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            if (!scaleFactorPixelsPerUnit || scaleFactorPixelsPerUnit === 0) {
                return `0.00 ft / 0.00 links`;
            }
            const lengthInFeet = lengthInPixels / scaleFactorPixelsPerUnit;
            const lengthInLinks = lengthInFeet / 0.66; // 1 link = 0.66 feet

            // Updated custom snapping logic with new thresholds
            let snappedLengthInLinks;
            if (lengthInLinks <= 0) {
                snappedLengthInLinks = 0;
            } else {
                const base = Math.floor(lengthInLinks / 2.5) * 2.5;
                const index = Math.round(base / 2.5);
                
                let threshold;
                // Check if the index is even or odd to determine the threshold
                if (index % 2 === 0) { // For snap points like 70, 75, 80... the threshold is +1.35
                    threshold = base + 1.35;
                } else { // For snap points like 72.5, 77.5... the threshold is +1.15
                    threshold = base + 1.15;
                }

                if (lengthInLinks >= threshold) {
                    snappedLengthInLinks = base + 2.5;
                } else {
                    snappedLengthInLinks = base;
                }
            }
            
            const snappedLengthInFeet = snappedLengthInLinks * 0.66; // Convert snapped links back to feet for consistency

            return `${snappedLengthInFeet.toFixed(2)} ft / ${snappedLengthInLinks.toFixed(2)} links`;
        }

        /**
         * Calculates the real-world area of a rectangle.
         * Expects four points representing the corners of the rectangle.
         * @param {Array<{x: number, y: number}>} points - Array of four corner points [c1, c2, c3, c4].
         * @returns {{sqFt: number, shotok: number}} Object containing square feet and shotok.
         */
        function calculateRectangleArea(points) {
            if (points.length !== 4) return { sqFt: null, shotok: null };

            // Calculate width and height from the first two sides (assuming it's a rectangle)
            const widthPixels = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
            const heightPixels = Math.hypot(points[3].x - points[0].x, points[3].y - points[0].y);

            const widthFeet = widthPixels / scaleFactorPixelsPerUnit;
            const heightFeet = heightPixels / scaleFactorPixelsPerUnit;
            const areaSqFt = widthFeet * heightFeet;
            const areaShotok = areaSqFt / 435.6; // 1 shotok = 435.6 sq ft
            return { sqFt: areaSqFt, shotok: areaShotok };
        }

        /**
         * Calculates the real-world area of a polygon using the Shoelace formula.
         * @param {Array<{x: number, y: number}>} points - Array of polygon vertices in canvas coordinates.
         * @returns {{sqFt: number, shotok: number} | {sqFt: null, shotok: null}} Object containing square feet and shotok, or null if less than 3 points.
         */
        function calculatePolygonArea(points) {
            if (points.length < 3) return { sqFt: null, shotok: null };
            let areaPixels = 0;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                areaPixels += (p1.x * p2.y - p2.x * p1.y);
            }
            areaPixels = Math.abs(areaPixels / 2); // Area in pixels²

            const areaSqFt = areaPixels / (scaleFactorPixelsPerUnit * scaleFactorPixelsPerUnit);
            const areaShotok = areaSqFt / 435.6; // 1 shotok = 435.6 sq ft
            return { sqFt: areaSqFt, shotok: areaShotok };
        }

        /**
         * Calculates the angle between three points (p1-p2-p3, where p2 is the vertex).
         * @param {{x: number, y: number}} p1 - First point.
         * @param {{x: number, y: number}} p2 - Vertex point.
         * @param {{x: number, y: number}} p3 - Third point.
         * @returns {string} Formatted angle string in degrees, or 'N/A' if points are coincident.
         */
        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            const magnitude1 = Math.hypot(v1.x, v1.y);
            const magnitude2 = Math.hypot(v2.x, v2.y);

            if (magnitude1 === 0 || magnitude2 === 0) return 'N/A';

            let angleRad = Math.acos(dotProduct / (magnitude1 * magnitude2));
            let angleDeg = angleRad * (180 / Math.PI);
            return `${angleDeg.toFixed(2)}°`;
        }

        /**
         * The main redraw function for the canvas.
         * This function is called repeatedly via requestAnimationFrame to keep the canvas updated.
         * It draws the loaded image/PDF, all existing measurements, and any temporary drawing in progress.
         */
        function redraw() {
            // Adjust canvas dimensions for high-DPI screens
            mainCanvas.width = mainCanvas.clientWidth * dpr;
            mainCanvas.height = mainCanvas.clientHeight * dpr;

            ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); // Clear the entire canvas

            ctx.save(); // Save the current state of the context
            ctx.scale(dpr, dpr); // Scale the context by device pixel ratio for sharp rendering
            ctx.translate(pan.x, pan.y); // Apply panning offset
            ctx.scale(zoom, zoom); // Apply zoom level

            // Get current line width and font size from UI inputs
            const currentLineWidth = parseFloat(lineWidthInput.value);
            const currentFontSize = parseFloat(fontSizeInput.value);

            // Draw the loaded image or PDF content
            if (imgLoaded) {
                // img.src contains the rendered image data (for both image and PDF after conversion)
                ctx.drawImage(img, 0, 0);
            }

            // Draw all existing measurements stored in the 'measurements' array
            measurements.forEach((m) => {
                ctx.strokeStyle = m.color || 'red'; // Use stored color or default to red
                ctx.lineWidth = currentLineWidth / zoom; // Adjust line width based on zoom
                ctx.fillStyle = m.color || 'blue'; // Use stored color or default to blue for text
                ctx.font = `${currentFontSize / zoom}px sans-serif`; // Adjust font size based on zoom
                ctx.textAlign = 'center'; // Center text for measurements
                ctx.textBaseline = 'middle'; // Center text vertically
                setLineStyle(ctx, m.lineStyle || 'solid'); // Use stored line style or default to solid

                if (m.type === 'line' || m.type === 'calibration') {
                    const [p1, p2] = m.points;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    drawPoint(ctx, p1.x, p1.y, zoom); // Points are always blue
                    drawPoint(ctx, p2.x, p2.y, zoom); // Points are always blue
                    if (m.value) { // Display value for calibration line
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        ctx.fillText(m.value, midX, midY - (currentFontSize / zoom / 2 + 2));
                    }
                } else if (m.type === 'rectangle') {
                    // Rectangle points are now stored as an array of 4 corners: [c1, c2, c3, c4]
                    // c1---c2
                    // |    |
                    // c4---c3
                    const [c1, c2, c3, c4] = m.points;
                    ctx.beginPath();
                    ctx.moveTo(c1.x, c1.y);
                    ctx.lineTo(c2.x, c2.y);
                    ctx.lineTo(c3.x, c3.y);
                    ctx.lineTo(c4.x, c4.y);
                    ctx.closePath(); // Close the rectangle path
                    ctx.stroke(); // Draw the rectangle outline
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; /* Transparent light gray fill */
                    ctx.fill(); // Fill the rectangle
                    ctx.fillStyle = m.color || 'blue'; /* Reset fillStyle for text */

                    // Draw segment measurements (length of each side)
                    const segments = [
                        { p1: c1, p2: c2 }, { p1: c2, p2: c3 },
                        { p1: c3, p2: c4 }, { p1: c4, p2: c1 }
                    ];
                    segments.forEach(seg => {
                        const midX = (seg.p1.x + seg.p2.x) / 2;
                        const midY = (seg.p1.y + seg.p2.y) / 2;
                        const length = calculateLineLength(seg.p1, seg.p2);
                        // Only display feet length for segments
                        ctx.fillText(length.split(' / ')[0], midX, midY - (currentFontSize / zoom / 2 + 2));
                    });

                    // Draw points at each corner
                    drawPoint(ctx, c1.x, c1.y, zoom); // Points are always blue
                    drawPoint(ctx, c2.x, c2.y, zoom); // Points are always blue
                    drawPoint(ctx, c3.x, c3.y, zoom); // Points are always blue
                    drawPoint(ctx, c4.x, c4.y, zoom); // Points are always blue

                    if (m.areaSqFt !== undefined && m.areaShotok !== undefined) {
                        // Center area text
                        const centerX = (c1.x + c3.x) / 2;
                        const centerY = (c1.y + c3.y) / 2;
                        const textOffset = currentFontSize / zoom / 2 + 2;
                        ctx.fillText(`${m.areaSqFt.toFixed(2)} sq ft`, centerX, centerY - textOffset);
                        ctx.fillText(`${m.areaShotok.toFixed(4)} shotok`, centerX, centerY + textOffset);
                    }
                } else if (m.type === 'polygon') {
                    if (m.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(m.points[0].x, m.points[0].y);
                        for (let i = 1; i < m.points.length; i++) {
                            ctx.lineTo(m.points[i].x, m.points[i].y);
                        }
                        if (m.points.length > 2 && m.closed) {
                            ctx.closePath(); // Close the polygon path if marked as closed
                            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; /* Transparent light gray fill */
                            ctx.fill(); // Fill the polygon
                            ctx.fillStyle = m.color || 'blue'; /* Reset fillStyle for text */
                        }
                        ctx.stroke(); // Draw the polygon outline

                        // Draw segment measurements for each side of the polygon
                        for (let i = 0; i < m.points.length; i++) {
                            const p1 = m.points[i];
                            const p2 = m.points[(i + 1) % m.points.length]; // Connect last to first if closed
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const length = calculateLineLength(p1, p2);
                            // Only display feet length for segments
                            ctx.fillText(length.split(' / ')[0], midX, midY - (currentFontSize / zoom / 2 + 2));
                        }

                        m.points.forEach(p => drawPoint(ctx, p.x, p.y, zoom)); // Points are always blue
                        if (m.closed && m.areaSqFt !== undefined && m.areaShotok !== undefined) {
                            // Display area in the centroid of the polygon
                            let sumX = 0, sumY = 0;
                            m.points.forEach(p => { sumX += p.x; sumY += p.y; });
                            const centroidX = sumX / m.points.length;
                            const centroidY = sumY / m.points.length; // Corrected: Use centroidY here
                            const textOffset = currentFontSize / zoom / 2 + 2;
                            // Display square feet on one line
                            ctx.fillText(`${m.areaSqFt.toFixed(2)} sq ft`, centroidX, centroidY - textOffset); // Corrected: Use centroidY
                            // Display shotok on the next line
                            ctx.fillText(`${m.areaShotok.toFixed(4)} shotok`, centroidX, centroidY + textOffset); // Corrected: Use centroidY
                        }
                    }
                } else if (m.type === 'angle') {
                    const [p1, p2, p3] = m.points; // p2 is the vertex of the angle
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.stroke(); // Draw the two arms of the angle
                    drawPoint(ctx, p1.x, p1.y, zoom); // Points are always blue
                    drawPoint(ctx, p2.x, p2.y, zoom); // Points are always blue
                    drawPoint(ctx, p3.x, p3.y, zoom); // Points are always blue

                    // Draw an arc to visually represent the angle
                    const angleRadius = 30 / zoom; // Size of the arc, adjusted for zoom
                    const startAngle = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                    const endAngle = Math.atan2(p3.y - p2.y, p3.x - p2.x);

                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, angleRadius, startAngle, endAngle);
                    ctx.stroke();

                    // Position text for angle value near the arc
                    const textAngle = (startAngle + endAngle) / 2;
                    const textX = p2.x + Math.cos(textAngle) * (angleRadius + 10 / zoom);
                    const textY = p2.y + Math.sin(textAngle) * (angleRadius + 10 / zoom);
                    ctx.fillText(m.value, textX, textY);

                    // Show arm lengths
                    const len1 = calculateLineLength(p1, p2);
                    const len2 = calculateLineLength(p2, p3);
                    ctx.fillText(len1.split(' / ')[0], (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 - (currentFontSize / zoom / 2 + 2));
                    ctx.fillText(len2.split(' / ')[0], (p2.x + p3.x) / 2, (p2.y + p3.y) / 2 - (currentFontSize / zoom / 2 + 2));
                } else if (m.type === 'circle') {
                    const [center, radiusPoint] = m.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2); // Draw the circle
                    ctx.stroke();
                    drawPoint(ctx, center.x, center.y, zoom); // Points are always blue
                    drawPoint(ctx, radiusPoint.x, radiusPoint.y, zoom); // Points are always blue
                    if (m.value) {
                        ctx.fillText(m.value, center.x, center.y - radius - (currentFontSize / zoom / 2 + 2)); // Display value above circle
                    }
                    // Show radius length
                    const radiusLength = calculateLineLength(center, radiusPoint);
                    ctx.fillText("Radius: " + radiusLength.split(' / ')[0], (center.x + radiusPoint.x) / 2, (center.y + radiusPoint.y) / 2 - (currentFontSize / zoom / 2 + 2));
                } else if (m.type === 'text') {
                    ctx.fillStyle = m.color || 'blue'; // Text color
                    ctx.font = `${currentFontSize / zoom}px sans-serif`;
                    ctx.fillText(m.text, m.points[0].x, m.points[0].y); // Draw text at its point
                }
            });

            // Ensure current drawing (temporary) is also drawn with selected style
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor; // This will be the fill color for temporary drawings (e.g., rect fill)
            ctx.lineWidth = currentLineWidth / zoom;
            ctx.font = `${currentFontSize / zoom}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            setLineStyle(ctx, currentLineStyle);

            // Draw current temporary drawing (e.g., line as it's being dragged, polygon segments)
            if (currentDrawing) {
                if (mode === 'line') { // Drag-to-draw tools
                    const [p1, p2] = currentDrawing.points;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    drawPoint(ctx, p1.x, p1.y, zoom); // Points are always blue
                    drawPoint(ctx, p2.x, p2.y, zoom); // Points are always blue
                } else if (mode === 'rectangle') { // Rectangle drawing temporary state
                    const [p1, currentMousePoint] = currentDrawing.points;
                    const c1 = { x: p1.x, y: p1.y };
                    const c2 = { x: currentMousePoint.x, y: p1.y };
                    const c3 = { x: currentMousePoint.x, y: currentMousePoint.y };
                    const c4 = { x: p1.x, y: currentMousePoint.y };

                    ctx.beginPath();
                    ctx.moveTo(c1.x, c1.y);
                    ctx.lineTo(c2.x, c2.y);
                    ctx.lineTo(c3.x, c3.y);
                    ctx.lineTo(c4.x, c4.y);
                    ctx.closePath();
                    ctx.stroke();

                    drawPoint(ctx, c1.x, c1.y, zoom); // Points are always blue
                    drawPoint(ctx, c2.x, c2.y, zoom); // Points are always blue
                    drawPoint(ctx, c3.x, c3.y, zoom); // Points are always blue
                    drawPoint(ctx, c4.x, c4.y, zoom); // Points are always blue
                } else if (mode === 'polygon') {
                    if (currentDrawing.points.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                        for (let i = 1; i < currentDrawing.points.length; i++) {
                            ctx.lineTo(currentDrawing.points[i].x, currentDrawing.points[i].y);
                        }
                        // Draw temporary line from last point to current mouse position (snapped)
                        const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                        currentDrawing.points.forEach(p => drawPoint(ctx, p.x, p.y, zoom)); // Points are always blue
                    }
                } else if (mode === 'angle' && currentDrawing.points.length > 0) {
                    drawPoint(ctx, currentDrawing.points[0].x, currentDrawing.points[0].y, zoom); // Points are always blue
                    if (currentDrawing.points.length === 1) { // Drawing first arm
                        const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.beginPath();
                        ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                    } else if (currentDrawing.points.length === 2) { // Drawing second arm
                        const [p1, p2] = currentDrawing.points; // p2 is vertex
                        const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                        drawPoint(ctx, p1.x, p1.y, zoom); // Points are always blue
                        drawPoint(ctx, p2.x, p2.y, zoom); // Points are always blue
                    }
                } else if (mode === 'circle' && currentDrawing.points.length > 0) {
                    const [center] = currentDrawing.points;
                    const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                    const radius = Math.hypot(mouseCanvasCoords.x - center.x, mouseCanvasCoords.y - center.y);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    drawPoint(ctx, center.x, center.y, zoom); // Points are always blue
                } else if (mode === 'calibrate' && currentDrawing.points.length >= 1) { // Live line for calibration (1 or 2 points)
                    const p1 = currentDrawing.points[0];
                    const p2 = currentDrawing.points.length === 2 ? currentDrawing.points[1] : getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    drawPoint(ctx, p1.x, p1.y, zoom); // Points are always blue
                    if (currentDrawing.points.length === 1) { // Only draw second point if still selecting
                        drawPoint(ctx, p2.x, p2.y, zoom); // Points are always blue
                    } else if (currentDrawing.points.length === 2) // Draw both points if selected for editing
                    {
                        drawPoint(ctx, currentDrawing.points[1].x, currentDrawing.points[1].y, zoom); // Points are always blue
                    }
                }
            }

            ctx.restore(); // Restore the context to its original state before this redraw

            // Draw magnifier content if active
            if (magnifierDiv.style.display === 'block') {
                magnifyCtx.clearRect(0, 0, MAGNIFIER_SIZE * dpr, MAGNIFIER_SIZE * dpr);

                // Get the current pointer position in CSS pixels relative to the main canvas's top-left
                const mainCanvasRect = mainCanvas.getBoundingClientRect();
                const pointerCssX_relativeToCanvas = lastPointerClientX - mainCanvasRect.left;
                const pointerCssY_relativeToCanvas = lastPointerClientY - mainCanvasRect.top;

                // The physical pixel coordinates on the mainCanvas's backing buffer where the cursor is
                const rawPixelX_under_cursor = pointerCssX_relativeToCanvas * dpr;
                const rawPixelY_under_cursor = pointerCssY_relativeToCanvas * dpr;

                // The size of the region to capture from the main canvas (in physical pixels).
                const sourceRegionPhysicalSize = (MAGNIFIER_SIZE / MAGNIFIER_ZOOM) * dpr;

                // Calculate the top-left corner of the source rectangle on the mainCanvas (physical pixels).
                // This rectangle will be centered around the rawPixelX_under_cursor/Y_under_cursor.
                const sourceX_physical = rawPixelX_under_cursor - (sourceRegionPhysicalSize / 2);
                const sourceY_physical = rawPixelY_under_cursor - (sourceRegionPhysicalSize / 2);

                // Draw a magnified portion of the main canvas onto the magnifier canvas
                magnifyCtx.drawImage(
                    mainCanvas,
                    sourceX_physical, sourceY_physical,
                    sourceRegionPhysicalSize, sourceRegionPhysicalSize,
                    0, 0, MAGNIFIER_SIZE * dpr, MAGNIFIER_SIZE * dpr
                );

                // Draw a crosshair in the center of the magnifier for precise aiming
                magnifyCtx.strokeStyle = 'lime'; // Bright green crosshair
                magnifyCtx.lineWidth = 1 / dpr; // Scale line width by DPR on magnifier
                magnifyCtx.beginPath();
                magnifyCtx.moveTo(MAGNIFIER_SIZE / 2, 0);
                magnifyCtx.lineTo(MAGNIFIER_SIZE / 2, MAGNIFIER_SIZE);
                magnifyCtx.moveTo(0, MAGNIFIER_SIZE / 2);
                magnifyCtx.lineTo(MAGNIFIER_SIZE, MAGNIFIER_SIZE / 2);
                magnifyCtx.stroke();
            }

            // Draw visual feedback for snapping (small green dot AND crosshair at snapped point)
            if (snappedToPoint) {
                ctx.save();
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Reset transform for drawing directly on screen pixels
                ctx.fillStyle = 'lime'; // Bright green color for snapped point
                ctx.strokeStyle = 'lime'; // Green for crosshair
                ctx.lineWidth = 1; // Thin crosshair line

                const screenSnappedX = snappedToPoint.x * zoom + pan.x;
                const screenSnappedY = snappedToPoint.y * zoom + pan.y;

                // Draw the green circle
                ctx.beginPath();
                ctx.arc(screenSnappedX, screenSnappedY, SNAP_RADIUS * 2, 0, Math.PI * 2); // Larger dot for visibility
                ctx.fill();

                // Draw the green crosshair (larger size)
                const crosshairSize = 100; // Increased size for the crosshair arms
                ctx.beginPath();
                ctx.moveTo(screenSnappedX - crosshairSize, screenSnappedY);
                ctx.lineTo(screenSnappedX + crosshairSize, screenSnappedY);
                ctx.moveTo(screenSnappedX, screenSnappedY - crosshairSize);
                ctx.lineTo(screenSnappedX, screenSnappedY + crosshairSize);
                ctx.stroke();

                ctx.restore(); // Restore context to previous state
            }

            requestAnimationFrame(redraw); // Request the next animation frame
        }

        /**
         * Renders the list of current measurements in the sidebar.
         * Clears the existing list and re-populates it with updated measurement data.
         * @param {Array<Object>} measurements - The array of measurement objects to render.
         */
        function renderMeasurementsList() {
            measurementsListDiv.innerHTML = ''; // Clear existing list items
            if (measurements.length === 0) {
                measurementsListDiv.innerHTML = '<p class="text-gray-600 text-sm">No measurements yet. Draw something!</p>';
                return;
            }
            // Create and append a div for each measurement
            measurements.forEach((m, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'measurement-item';
                let displayText = '';
                let buttonsHtml = `<button data-index="${index}" class="delete-btn">Delete</button>`;

                // Determine display text based on measurement type
                if (m.type === 'line') {
                    displayText = `Line: ${m.value}`;
                } else if (m.type === 'rectangle') {
                    displayText = `Rectangle: ${m.value}`;
                } else if (m.type === 'polygon') {
                    displayText = `Polygon: ${m.areaSqFt.toFixed(2)} sq ft / ${m.areaShotok.toFixed(4)} shotok`;
                } else if (m.type === 'angle') {
                    displayText = `Angle: ${m.value}`;
                } else if (m.type === 'circle') {
                    displayText = `Circle (R:${m.radius.toFixed(2)}ft): ${m.value}`;
                } else if (m.type === 'text') {
                    displayText = `Text: "${m.text}"`;
                    buttonsHtml += `<button data-index="${index}" class="edit-btn">Edit</button>`;
                } else if (m.type === 'calibration') {
                    displayText = `Calibration: ${m.value}`;
                }
                // Add measurement text and buttons
                itemDiv.innerHTML = `
                    <span class="text-sm font-medium text-gray-800">${displayText}</span>
                    <div>${buttonsHtml}</div>
                `;
                measurementsListDiv.appendChild(itemDiv);
            });
        }

        /**
         * Saves the current state of 'measurements' into the history stack.
         * This is called after any action that changes the measurements, for Undo/Redo.
         */
        function saveState() {
            // If pointer is not at the end of history, clear future states
            if (historyPointer < measurementHistory.length - 1) {
                measurementHistory = measurementHistory.slice(0, historyPointer + 1);
            }
            // Deep copy measurements to avoid reference issues
            measurementHistory.push(JSON.parse(JSON.stringify(measurements)));
            historyPointer = measurementHistory.length - 1;
            updateUndoRedoButtons();
        }

        /**
         * Updates the disabled state of Undo and Redo buttons based on history pointer.
         */
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyPointer <= 0;
            redoBtn.disabled = historyPointer >= measurementHistory.length - 1;
        }

        /**
         * Loads a specific state from history.
         * @param {number} index - The index in the history to load.
         */
        function loadState(index) {
            if (index >= 0 && index < measurementHistory.length) {
                measurements = JSON.parse(JSON.stringify(measurementHistory[index]));
                historyPointer = index;
                renderMeasurementsList();
                redraw();
                updateUndoRedoButtons();
            }
        }


        // Variables to track last pointer position for magnifier and temporary drawing feedback
        let lastPointerClientX = 0;
        let lastPointerClientY = 0;

        // --- Event Handlers for Canvas Interaction ---

        /**
         * Handles pointer down (mouse click or touch start) events on the main canvas.
         * Initiates panning, drawing, or point selection based on the current mode.
         * @param {PointerEvent} e - The pointerdown event object.
         */
        function handlePointerDown(e) {
            if (e.button === 2) return; // Ignore right-click

            // Get canvas coordinates, potentially snapping to existing points
            const { x, y } = getSnappedCanvasCoords(e.clientX, e.clientY);

            // Store starting point for drag calculations (screen coords for pan, canvas coords for drawing/editing)
            startPoint = { clientX: e.clientX, clientY: e.clientY, x, y };
            isDragging = true;

            // Update last pointer position for magnifier
            lastPointerClientX = e.clientX;
            lastPointerClientY = e.clientY;

            // Reset snappedToPoint visual cue at the start of a drag/click
            snappedToPoint = null;

            if (mode === 'pan') {
                magnifierDiv.style.display = 'none'; // Hide magnifier in pan mode
            } else if (mode === 'calibrate') {
                if (!currentDrawing) { // First click for calibration
                    currentDrawing = { type: 'calibrate', points: [{ x, y }] };
                    outputDisplay.innerText = 'First calibration point set. Now move your mouse to the second point and click.';
                    magnifierDiv.style.display = 'block';
                } else if (currentDrawing.type === 'calibrate' && currentDrawing.points.length === 1) { // Second click for calibration
                    currentDrawing.points.push({ x, y }); // Add the second point
                    outputDisplay.innerText = 'Second calibration point set. Adjust line if needed, then click "Confirm".';
                    confirmCalibrationBtn.style.display = 'inline-block'; // Show confirm button
                    magnifierDiv.style.display = 'none'; // Hide magnifier after second click
                    // Now, set selectedPoint to allow dragging of the newly added point
                    selectedPoint = { measurementIndex: -1, pointIndex: 1, type: 'calibrate' }; // -1 indicates currentDrawing
                }
            }
            else if (mode === 'line') {
                currentDrawing = { type: 'line', points: [{ x, y }, { x, y }] };
                outputDisplay.innerText = 'Click and drag to draw a line.';
                magnifierDiv.style.display = 'block';
            } else if (mode === 'rectangle') {
                currentDrawing = { type: 'rectangle', points: [{ x, y }, { x, y }] }; // Temporary stores two diagonal points
                outputDisplay.innerText = 'Click and drag to draw a rectangle.';
                magnifierDiv.style.display = 'block';
            } else if (mode === 'polygon') {
                if (!currentDrawing || currentDrawing.points.length === 0) { // Starting new polygon
                    currentDrawing = { type: 'polygon', points: [{ x, y }], closed: false };
                    outputDisplay.innerText = 'Click to add points for polygon. Double-click to finish.';
                } else { // Adding point to existing polygon
                    currentDrawing.points.push({ x, y });
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'angle') {
                if (!currentDrawing) {
                    currentDrawing = { type: 'angle', points: [{ x, y }] }; // First point (arm 1 end)
                    outputDisplay.innerText = '1: End of first arm. 2: Vertex. 3: End of second arm.';
                } else if (currentDrawing.points.length === 1) {
                    currentDrawing.points.push({ x, y }); // Second point (vertex)
                } else if (currentDrawing.points.length === 2) {
                    currentDrawing.points.push({ x, y }); // Third point (arm 2 end)
                    const [p1, p2, p3] = currentDrawing.points;
                    measurements.push({
                        id: Date.now() + '-angle',
                        type: 'angle',
                        points: currentDrawing.points,
                        value: calculateAngle(p1, p2, p3),
                        color: currentColor, // Save current color
                        lineStyle: currentLineStyle // Save current line style
                    });
                    outputDisplay.innerText = 'Angle drawn. Value: ' + measurements[measurements.length - 1].value;
                    currentDrawing = null;
                    magnifierDiv.style.display = 'none';
                    mode = 'pan'; // Reset mode
                    updateModeButtons();
                    renderMeasurementsList();
                    canvasContainer.classList.remove('drawing-mode');
                    saveState(); // Save state after completing angle drawing
                    return; // Exit to prevent further processing as measurement is complete
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'circle') {
                if (!currentDrawing) {
                    currentDrawing = { type: 'circle', points: [{ x, y }] }; // First point (center)
                    outputDisplay.innerText = '1: Circle center. 2: Radius point.';
                } else if (currentDrawing.points.length === 1) {
                    currentDrawing.points.push({ x, y }); // Second point (radius point)
                    const [center, radiusPoint] = currentDrawing.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                    const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit); // Correct circle area
                    const areaShotok = areaSqFt / 435.6;


                    measurements.push({
                        id: Date.now() + '-circle',
                        type: 'circle',
                        points: currentDrawing.points,
                        radius: radius / scaleFactorPixelsPerUnit, // Radius in feet
                        value: `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`,
                        areaSqFt: areaSqFt, // Store numeric value
                        areaShotok: areaShotok, // Store numeric value
                        color: currentColor, // Save current color
                        lineStyle: currentLineStyle // Save current line style
                    });
                    outputDisplay.innerText = 'Circle drawn. ' + measurements[measurements.length - 1].value;
                    currentDrawing = null;
                    magnifierDiv.style.display = 'none';
                    mode = 'pan'; // Reset mode
                    updateModeButtons();
                    renderMeasurementsList();
                    canvasContainer.classList.remove('drawing-mode');
                    saveState(); // Save state after completing circle drawing
                    return; // Exit to prevent further processing as measurement is complete
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'text') {
                const textInput = prompt("Enter text for the note:");
                if (textInput !== null && textInput.trim() !== '') {
                    measurements.push({
                        id: Date.now() + '-text',
                        type: 'text',
                        points: [{ x, y }],
                        text: textInput.trim(),
                        color: currentColor // Save current color
                    });
                    outputDisplay.innerText = 'Text note added.';
                    renderMeasurementsList();
                    saveState(); // Save state after completing text drawing
                } else {
                    outputDisplay.innerText = 'Text note cancelled.';
                }
                magnifierDiv.style.display = 'none';
                mode = 'pan'; // Reset mode after placing text
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                return;
            }

            // Check for point selection for editing existing measurements (only in pan mode or if no drawing in progress)
            // If in calibrate mode AND we have 2 points, also allow selection of the points in `currentDrawing`.
            if (mode === 'pan' || (!currentDrawing && mode !== 'calibrate') || (currentDrawing && currentDrawing.type === 'calibrate' && currentDrawing.points.length === 2)) {
                selectedPoint = null; // Reset

                // Check existing measurements
                for (const m of measurements) {
                    // Include text in point selection for dragging
                    if (m.type === 'text') {
                        const p = m.points[0]; // Text only has one point
                        const screenP = getScreenCoords(p.x, p.y);
                        // A larger hit radius for text to make it easier to select
                        const effectiveHitRadius = HIT_RADIUS_BASE * 2;
                        if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                            selectedPoint = { measurementIndex: measurements.indexOf(m), pointIndex: 0, type: m.type };
                            currentDrawing = null; // Ensure no new drawing starts if editing an existing measurement
                            magnifierDiv.style.display = 'block';
                            return; // Stop checking after finding one
                        }
                    } else { // For other geometric shapes
                        for (let pIdx = 0; pIdx < m.points.length; pIdx++) {
                            const p = m.points[pIdx];
                            const screenP = getScreenCoords(p.x, p.y);
                            const effectiveHitRadius = HIT_RADIUS_BASE;
                            if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                                selectedPoint = { measurementIndex: measurements.indexOf(m), pointIndex: pIdx, type: m.type };
                                currentDrawing = null; // Ensure no new drawing starts if editing an existing measurement
                                magnifierDiv.style.display = 'block';
                                return; // Stop checking after finding one
                            }
                        }
                    }
                }

                // Check points of `currentDrawing` if in calibrate mode with 2 points
                if (mode === 'calibrate' && currentDrawing && currentDrawing.points.length === 2) {
                    for (let pIdx = 0; pIdx < currentDrawing.points.length; pIdx++) {
                        const p = currentDrawing.points[pIdx];
                        const screenP = getScreenCoords(p.x, p.y);
                        const effectiveHitRadius = HIT_RADIUS_BASE;
                        if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                            selectedPoint = { measurementIndex: -1, pointIndex: pIdx, type: 'calibrate' }; // -1 indicates currentDrawing
                            magnifierDiv.style.display = 'block';
                            return; // Stop checking after finding one
                        }
                    }
                }
            }
            // Task 3: Check for shape move
            if (mode === 'pan' && !selectedPoint) {
                const clickPoint = { x, y };
                // Iterate backwards to select the top-most shape
                for (let i = measurements.length - 1; i >= 0; i--) {
                    const m = measurements[i];
                    let wasHit = false;

                    if (m.type === 'line' || (m.type === 'polygon' && m.closed) || m.type === 'rectangle') {
                        let segments = [];
                        if (m.type === 'line') segments.push(m.points);
                        if (m.type === 'rectangle') {
                            const [c1, c2, c3, c4] = m.points;
                            segments.push([c1, c2], [c2, c3], [c3, c4], [c4, c1]);
                        }
                        if (m.type === 'polygon') {
                            for (let j = 0; j < m.points.length; j++) {
                                segments.push([m.points[j], m.points[(j + 1) % m.points.length]]);
                            }
                        }

                        for (const seg of segments) {
                            const [p1, p2] = seg;
                            // Check if click is near the line segment
                            const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                            const dist1 = Math.hypot(clickPoint.x - p1.x, clickPoint.y - p1.y);
                            const dist2 = Math.hypot(clickPoint.x - p2.x, clickPoint.y - p2.y);
                            // If sum of distances from point to ends is close to segment length, it's a hit
                            if (Math.abs(dist1 + dist2 - dist) < (HIT_RADIUS_BASE / zoom) * 0.5) {
                                wasHit = true;
                                break;
                            }
                        }
                    }
                    
                    if (wasHit) {
                        selectedPoint = {
                            measurementIndex: i,
                            type: 'move-shape', // Special type for moving
                            initialPan: { ...pan } // Store initial pan
                        };
                        canvasContainer.style.cursor = 'move';
                        return; // Exit after finding a shape to move
                    }
                }
            }
        }

        /**
         * Handles pointer move events on the main canvas.
         * Updates pan, draws temporary lines/shapes, and updates magnifier content.
         * @param {PointerEvent} e - The pointermove event object.
         */
        function handlePointerMove(e) {
            lastPointerClientX = e.clientX;
            lastPointerClientY = e.clientY;

            // Get canvas coordinates, potentially snapped to existing points or lines
            let { x: currentCanvasX, y: currentCanvasY } = getSnappedCanvasCoords(e.clientX, e.clientY);

            if (selectedPoint) {
                // Task 3: Handle shape move
                if (selectedPoint.type === 'move-shape') {
                    const deltaX = (e.clientX - startPoint.clientX) / zoom;
                    const deltaY = (e.clientY - startPoint.clientY) / zoom;
                    
                    const meas = measurements[selectedPoint.measurementIndex];
                    meas.points.forEach(p => {
                        p.x += deltaX;
                        p.y += deltaY;
                    });
                    
                    startPoint.clientX = e.clientX;
                    startPoint.clientY = e.clientY;
                    renderMeasurementsList();
                    return; // Stop further processing
                }
                // If a point of an existing measurement or currentDrawing is selected for editing
                if (selectedPoint.measurementIndex !== -1) { // Editing an existing measurement
                    const meas = measurements[selectedPoint.measurementIndex];

                    if (selectedPoint.type === 'line' || selectedPoint.type === 'calibration') {
                        meas.points[selectedPoint.pointIndex] = { x: currentCanvasX, y: currentCanvasY };
                        if (selectedPoint.type === 'line') {
                            meas.value = calculateLineLength(meas.points[0], meas.points[1]);
                        }
                        // If a calibration line point is dragged, update its stored points but don't recalculate scale here
                        // The user needs to explicitly click "Confirm Calibration"
                    } else if (selectedPoint.type === 'rectangle') {
                        const [c1, c2, c3, c4] = meas.points;
                        const draggedPointIndex = selectedPoint.pointIndex;
                        const originalX = meas.points[draggedPointIndex].x;
                        const originalY = meas.points[draggedPointIndex].y;

                        // Update the dragged point directly
                        meas.points[draggedPointIndex] = { x: currentCanvasX, y: currentCanvasY };

                        // Adjust other points based on which corner was dragged to maintain rectangle shape
                        if (draggedPointIndex === 0) { // c1 (top-left) dragged
                            c2.y = currentCanvasY; // c2 (top-right) Y follows c1
                            c4.x = currentCanvasX; // c4 (bottom-left) X follows c1
                        } else if (draggedPointIndex === 1) { // c2 (top-right) dragged
                            c1.y = currentCanvasY; // c1 (top-left) Y follows c2
                            c3.x = currentCanvasX; // c3 (bottom-right) X follows c2
                        } else if (draggedPointIndex === 2) { // c3 (bottom-right) dragged
                            c4.y = currentCanvasY; // c4 (bottom-left) Y follows c3
                            c2.x = currentCanvasX; // c2 (top-right) X follows c3
                        } else if (draggedPointIndex === 3) { // c4 (bottom-left) dragged
                            c3.x = currentCanvasX; // c3 (bottom-right) X follows c4
                            c1.y = currentCanvasY; // c1 (top-left) Y follows c4
                        }

                        // Recalculate area and update value string
                        const areaResult = calculateRectangleArea(meas.points);
                        meas.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                        meas.areaSqFt = areaResult.sqFt;
                        meas.areaShotok = areaResult.shotok;

                    } else if (selectedPoint.type === 'polygon' || selectedPoint.type === 'angle' || selectedPoint.type === 'circle') {
                        // Update point for polygon, angle, or circle
                        meas.points[selectedPoint.pointIndex] = { x: currentCanvasX, y: currentCanvasY };
                        if (selectedPoint.type === 'polygon') {
                            const areaResult = calculatePolygonArea(meas.points);
                            meas.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                            meas.areaSqFt = areaResult.sqFt;
                            meas.areaShotok = areaResult.shotok;
                        } else if (selectedPoint.type === 'angle') {
                            const [p1, p2, p3] = meas.points;
                            meas.value = calculateAngle(p1, p2, p3);
                        } else if (selectedPoint.type === 'circle') {
                            const [center, radiusPoint] = meas.points;
                            const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                            const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                            const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                            const areaShotok = areaSqFt / 435.6;
                            meas.radius = radius / scaleFactorPixelsPerUnit;
                            meas.value = `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
                            meas.areaSqFt = areaSqFt;
                            meas.areaShotok = areaShotok;
                        }
                    } else if (selectedPoint.type === 'text') {
                        // Update position for text
                        meas.points[0] = { x: currentCanvasX, y: currentCanvasY };
                    }
                } else if (selectedPoint.measurementIndex === -1 && selectedPoint.type === 'calibrate') {
                    // Editing a point of the temporary currentDrawing calibration line
                    currentDrawing.points[selectedPoint.pointIndex] = { x: currentCanvasX, y: currentCanvasY };
                    outputDisplay.innerText = 'Adjusting calibration line...';
                }
                renderMeasurementsList(); // Update list after editing
            } else if (mode === 'pan' && isDragging) {
                // If in pan mode and dragging, update the pan offset
                pan.x += (e.clientX - startPoint.clientX);
                pan.y += (e.clientY - startPoint.clientY);
                startPoint.clientX = e.clientX;
                startPoint.clientY = e.clientY;
            } else if (currentDrawing && isDragging && (mode === 'line' || mode === 'rectangle')) {
                // For drag-to-draw tools (line, rectangle), update the second point
                if (mode === 'line') {
                    currentDrawing.points[1] = { x: currentCanvasX, y: currentCanvasY };
                } else if (mode === 'rectangle') {
                    currentDrawing.points[1] = { x: currentCanvasX, y: currentCanvasY };
                }
            }
            // For multi-click drawing modes (polygon, angle, circle, calibrate with 1 point),
            // temporary lines/shapes are drawn in redraw based on `lastPointerClientX/Y`
            // and `currentDrawing` points. No direct modification to `currentDrawing.points` needed here on move.
        }

        /**
         * Handles pointer up (mouse release or touch end) events on the main canvas.
         * Finalizes drawings or releases selected points.
         */
        function handlePointerUp() {
            if (selectedPoint && selectedPoint.type === 'move-shape') {
                saveState(); // Save state after moving the shape
                selectedPoint = null;
                isDragging = false;
                canvasContainer.style.cursor = 'default'; // Reset cursor
                return;
            }
            isDragging = false;

            // If we were dragging a calibration point, clear the temporary `selectedPoint` and `currentDrawing`.
            // The actual calibration is confirmed via the button.
            if (selectedPoint && selectedPoint.type === 'calibrate' && selectedPoint.measurementIndex === -1) {
                // Do not clear currentDrawing here. It stays until confirmed or cancelled.
                // Re-set selectedPoint to null.
                selectedPoint = null;
                outputDisplay.innerText = 'Calibration line adjusted. Click "Confirm" to finalize or "Calibrate" to redraw.';
            } else {
                selectedPoint = null; // Clear selected point after release for other modes
            }

            magnifierDiv.style.display = 'none'; // Deactivate magnifier on pointer up

            // Finalize drawing for drag-to-draw tools (line, rectangle)
            if (currentDrawing && (mode === 'line' || mode === 'rectangle')) {
                if (mode === 'line') {
                    const line = {
                        id: Date.now() + '-line',
                        type: 'line',
                        points: currentDrawing.points,
                        value: calculateLineLength(currentDrawing.points[0], currentDrawing.points[1]),
                        color: currentColor, // Save current color
                        lineStyle: currentLineStyle // Save current line style
                    };
                    measurements.push(line);
                    outputDisplay.innerText = 'Line drawn. Length: ' + line.value;
                } else if (mode === 'rectangle') {
                    const [p1, p2] = currentDrawing.points; // p1 is start, p2 is end of drag
                    // Calculate all four corner points from the two diagonal points
                    const c1 = { x: p1.x, y: p1.y };
                    const c2 = { x: p2.x, y: p1.y };
                    const c3 = { x: p2.x, y: p2.y };
                    const c4 = { x: p1.x, y: p2.y };

                    const rectPoints = [c1, c2, c3, c4]; // Store all four corners
                    const areaResult = calculateRectangleArea(rectPoints);
                    const rect = {
                        id: Date.now() + '-rect',
                        type: 'rectangle',
                        points: rectPoints, // Store all 4 points
                        value: `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`,
                        areaSqFt: areaResult.sqFt,
                        areaShotok: areaResult.shotok,
                        color: currentColor, // Save current color
                        lineStyle: currentLineStyle // Save current line style
                    };
                    measurements.push(rect);
                    outputDisplay.innerText = 'Rectangle drawn. Area: ' + rect.value;
                }
                currentDrawing = null; // Clear current drawing for drag-to-draw tools
                renderMeasurementsList(); // Update list after new measurement
                saveState(); // Save state after completing a drawing action
            }

            // Revert to pan mode if a drawing action (excluding multi-click modes like polygon, angle, circle, calibrate) is completed.
            // For calibrate, we explicitly wait for confirmCalibrationBtn click.
            if (mode !== 'polygon' && mode !== 'angle' && mode !== 'circle' && mode !== 'calibrate') {
                mode = 'pan'; // Reset to pan mode
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
            }
        }

        /**
         * Handles double-click events on the main canvas.
         * Used to finalize polygon drawing.
         * @param {MouseEvent} e - The dblclick event object.
         */
        function handleDoubleClick(e) {
            e.preventDefault();
            if (mode === 'polygon' && currentDrawing && currentDrawing.points.length >= 3) {
                const areaResult = calculatePolygonArea(currentDrawing.points);
                const polygon = {
                    id: Date.now() + '-poly',
                    type: 'polygon',
                    points: currentDrawing.points,
                    closed: true, // Mark as closed
                    value: `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`,
                    areaSqFt: areaResult.sqFt,
                    areaShotok: areaResult.shotok,
                    color: currentColor, // Save current color
                    lineStyle: currentLineStyle // Save current line style
                };
                measurements.push(polygon);
                outputDisplay.innerText = 'Polygon drawn. Area: ' + polygon.value;
                currentDrawing = null;
                renderMeasurementsList(); // Update list after new measurement
                mode = 'pan'; // Reset to pan mode
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
                saveState(); // Save state after completing polygon drawing
            }
            magnifierDiv.style.display = 'none'; // Deactivate magnifier on double click for polygon
        }

        /**
         * Handles mouse wheel events for zooming.
         * Zooms in/out centered on the mouse pointer.
         * @param {WheelEvent} e - The wheel event object.
         */
        function handleWheel(e) {
            e.preventDefault(); // Prevent default browser scroll/zoom
            const zoomAmount = e.deltaY < 0 ? 1.1 : 0.9; // Determine zoom direction and factor

            const rect = mainCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; // Mouse X relative to canvas
            const mouseY = e.clientY - rect.top; // Mouse Y relative to canvas

            // Calculate mouse position in canvas coordinates BEFORE zooming
            const canvasX = (mouseX - pan.x) / zoom;
            const canvasY = (mouseY - pan.y) / zoom;

            zoom *= zoomAmount; // Apply new zoom level

            // Adjust pan to keep the mouse point fixed on the canvas
            pan.x = mouseX - canvasX * zoom;
            pan.y = mouseY - canvasY * zoom;
        }

        // Variables for touch pinch-to-zoom
        let lastTouchDist = null;

        /**
         * Handles touch start events for panning and pinch-to-zoom.
         * @param {TouchEvent} e - The touchstart event object.
         */
        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                // If two fingers, initiate pinch-to-zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.hypot(dx, dy); // Store initial distance between fingers
                magnifierDiv.style.display = 'none'; // Hide magnifier during multi-touch
                currentDrawing = null; // Clear any partial drawing if multi-touch starts
                mode = 'pan'; // Force pan mode on multi-touch
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
            } else if (e.touches.length === 1) {
                // If one finger, treat as a single pointer down event (for drawing/panning)
                handlePointerDown(e.touches[0]);
            }
        }

        /**
         * Handles touch move events for panning and pinch-to-zoom.
         * @param {TouchEvent} e - The touchmove event object.
         */
        function handleTouchMove(e) {
            // Update last pointer client coordinates for magnifier, even during touch
            if (e.touches.length === 1 && magnifierDiv.style.display === 'block') {
                lastPointerClientX = e.touches[0].clientX;
                lastPointerClientY = e.touches[0].clientY;
            }

            if (e.touches.length === 2) {
                // If two fingers, perform pinch-to-zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy); // Current distance between fingers

                if (lastTouchDist) {
                    const zoomAmount = newDist / lastTouchDist; // Calculate zoom factor
                    const rect = mainCanvas.getBoundingClientRect();
                    // Calculate center of the two touches
                    const touchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const touchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                    // Convert touch center to canvas coordinates
                    const canvasX = (touchX - rect.left - pan.x) / zoom;
                    const canvasY = (touchY - rect.y - pan.y) / zoom;

                    zoom *= zoomAmount; // Apply new zoom
                    // Adjust pan to keep the pinch center fixed
                    pan.x = touchX - rect.left - canvasX * zoom;
                    pan.y = touchY - rect.y - canvasY * zoom;
                }
                lastTouchDist = newDist; // Update last distance for next move
                e.preventDefault(); // Prevent default browser gestures (e.g., scrolling)
            } else if (e.touches.length === 1) {
                // If one finger, treat as a single pointer move event
                handlePointerMove(e.touches[0]);
            }
        }

        /**
         * Handles touch end events.
         * Resets touch tracking variables.
         * @param {TouchEvent} e - The touchend event object.
         */
        function handleTouchEnd(e) {
            lastTouchDist = null; // Clear pinch-to-zoom state
            if (e.touches.length === 0) {
                // If all fingers are lifted, treat as a single pointer up event
                handlePointerUp();
            }
        }

        // --- File Loading Logic ---

        let currentPdfPage = null; // To store the PDF page for direct rendering

        async function loadFile(file) {
            if (!file) return;

            // Reset canvas state and measurements
            imgLoaded = false;
            img.src = ''; // Clear previous image or PDF dataURL
            measurements = [];
            measurementHistory = []; // Clear history on new file load
            historyPointer = -1; // Reset history pointer
            updateUndoRedoButtons(); // Update button state
            renderMeasurementsList();
            outputDisplay.innerText = 'Loading file...';
            mode = 'pan'; // Reset mode to pan
            updateModeButtons();
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
            confirmCalibrationBtn.style.display = 'none'; // Hide confirm button on new file load
            currentPdfPage = null; // Clear previous PDF page reference

            // Set initial scale parameters from UI inputs
            updateScaleValues(currentScaleSetting); // Set default scale and calculate initial scaleFactorPixelsPerUnit


            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    img.onload = () => {
                        imgLoaded = true;
                        // Center image on load
                        pan = {
                            x: (mainCanvas.clientWidth - img.width * zoom) / 2,
                            y: (mainCanvas.clientHeight - img.height * zoom) / 2,
                        };
                        zoom = 1; // Reset zoom
                        outputDisplay.innerText = `Image loaded. Scale: ${currentScaleSetting}. Start measuring now.`;
                        redraw(); // Force a redraw
                        saveState(); // Save initial state to history
                    };
                    img.src = event.target.result; // Set image source from file
                };
                reader.readAsDataURL(file); // Read image as Data URL
            } else if (file.type === 'application/pdf') {
                outputDisplay.innerText = 'Loading PDF... Please wait.';
                const reader = new FileReader();
                reader.onload = function(event) {
                    const pdfData = new Uint8Array(event.target.result);

                    pdfjsLib.getDocument({ data: pdfData }).promise.then(function(pdf) {
                        outputDisplay.innerText = `PDF loaded (${pdf.numPages} pages). Rendering page 1...`;
                        return pdf.getPage(1);
                    }).then(function(page) {
                        currentPdfPage = page; // Store the page object for direct rendering
                        const desiredPpi = currentDpi; // Use fixed DPI for PDF rendering
                        const scale = desiredPpi / 72;
                        const viewport = page.getViewport({ scale: scale });

                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = viewport.width;
                        tempCanvas.height = viewport.height;

                        const renderContext = { canvasContext: tempCtx, viewport: viewport };
                        return page.render(renderContext).promise.then(() => {
                            // After rendering is complete on tempCanvas, update img.src
                            img.onload = () => {
                                imgLoaded = true;
                                pan = {
                                    x: (mainCanvas.clientWidth - img.width * zoom) / 2,
                                    y: (mainCanvas.clientHeight - img.height * zoom) / 2,
                                };
                                zoom = 1;
                                outputDisplay.innerText = `PDF page 1 loaded as image. Scale: ${currentScaleSetting}. Start measuring now.`;
                                redraw();
                                saveState(); // Save initial state to history
                            };
                            // Use the tempCanvas directly for toDataURL
                            img.src = tempCanvas.toDataURL('image/png');
                            tempCanvas.remove(); // Clean up the temporary canvas
                        });
                    }).catch(err => {
                        outputDisplay.innerText = 'Error loading PDF: ' + err.message + '. Ensure the file is valid and you are serving this HTML file from a web server (e.g., http://localhost) due to browser security restrictions on local files.';
                        console.error('PDF.js error:', err);
                    });
                };
                reader.readAsArrayBuffer(file); // Read PDF as ArrayBuffer
            } else {
                outputDisplay.innerText = 'Unsupported file type. Please load an image or PDF file.';
            }
        }


        // Event listener for image/PDF file input change
        imageLoader.addEventListener('change', (e) => {
            loadFile(e.target.files[0]);
        });

        // --- Drag and Drop functionality for loading files ---
        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); // Prevent default dragover behavior
            e.stopPropagation(); // Stop event propagation
            e.dataTransfer.dropEffect = 'copy'; // Visual feedback for drop operation
            canvasContainer.style.borderColor = '#3b82f6'; // Highlight drag area
        });

        canvasContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.style.borderColor = 'transparent'; // Reset border on drag leave
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.style.borderColor = 'transparent'; // Reset border on drop
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                loadFile(e.dataTransfer.files[0]); // Load the dropped file
            }
        });

        /**
         * Updates the current scale values based on the selected scale setting.
         * @param {string} scaleSetting - The selected scale string (e.g., '16inch=1mile').
         */
        function updateScaleValues(scaleSetting) {
            currentScaleSetting = scaleSetting;
            switch (scaleSetting) {
                case '16inch=1mile':
                    FEET_PER_INCH_CURRENT = 330;
                    break;
                case '32inch=1mile':
                    FEET_PER_INCH_CURRENT = 165;
                    break;
                case '48inch=1mile': // নতুন স্কেল
                    FEET_PER_INCH_CURRENT = 5280 / 48; // 1 mile = 5280 feet
                    break;
                case '64inch=1mile':
                    FEET_PER_INCH_CURRENT = 82.5;
                    break;
                default:
                    FEET_PER_INCH_CURRENT = 330; // Fallback
            }
            scaleFactorPixelsPerUnit = currentDpi / FEET_PER_INCH_CURRENT;
            scaleButton.textContent = `Scale: ${scaleSetting}`;
            outputDisplay.innerText = `Scale updated to: ${scaleSetting}.`;

            // Recalculate all existing measurements based on new scale
            measurements.forEach(m => {
                if (m.type === 'line' || m.type === 'calibration') {
                    m.value = calculateLineLength(m.points[0], m.points[1]);
                } else if (m.type === 'rectangle') {
                    const areaResult = calculateRectangleArea(m.points);
                    m.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                    m.areaSqFt = areaResult.sqFt;
                    m.areaShotok = areaResult.shotok;
                } else if (m.type === 'polygon') {
                    const areaResult = calculatePolygonArea(m.points);
                    m.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                    m.areaSqFt = areaResult.sqFt;
                    m.areaShotok = areaResult.shotok;
                } else if (m.type === 'angle') {
                    // Angle value doesn't change with scale, but arm lengths might be displayed
                    // No direct recalculation of m.value for angle itself, but if arm lengths are part of it, they would update.
                } else if (m.type === 'circle') {
                    const [center, radiusPoint] = m.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                    const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                    const areaShotok = areaSqFt / 435.6;
                    m.radius = radius / scaleFactorPixelsPerUnit;
                    m.value = `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
                    m.areaSqFt = areaSqFt;
                    m.areaShotok = areaShotok;
                }
                // Text measurements don't change with scale
            });
            renderMeasurementsList();
            redraw();
        }


        // Event listener for "Calibrate Scale" button
        calibrateScaleBtn.addEventListener('click', () => {
            if (!imgLoaded) {
                outputDisplay.innerText = 'Please load an image or PDF first.';
                return;
            }
            // If already in calibration mode, clicking again cancels it
            if (mode === 'calibrate') {
                mode = 'pan';
                currentDrawing = null; // Clear current calibration line
                confirmCalibrationBtn.style.display = 'none';
                outputDisplay.innerText = 'Calibration cancelled.';
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                return;
            }

            mode = 'calibrate'; // Set mode to calibrate
            currentDrawing = null; // Clear any existing temporary drawing
            outputDisplay.innerText = 'Click the first point for calibration.';
            updateModeButtons(); // Update button highlighting
            canvasContainer.classList.add('drawing-mode'); // Show crosshair cursor
            confirmCalibrationBtn.style.display = 'none'; // Ensure confirm button is hidden initially
        });

        // Event listener for "Confirm Calibration" button
        confirmCalibrationBtn.addEventListener('click', () => {
            // Only proceed if in calibrate mode and a two-point line has been drawn
            if (mode === 'calibrate' && currentDrawing && currentDrawing.points.length === 2) {
                const [p1, p2] = currentDrawing.points;
                const pixelDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                // Prompt user for the real-world distance
                let realWorldLength = parseFloat(prompt("Enter the real-world distance (in feet) between the two points:"));

                if (!isNaN(realWorldLength) && realWorldLength > 0) {
                    // Recalculate scale factor
                    scaleFactorPixelsPerUnit = pixelDistance / realWorldLength;
                    // Update FEET_PER_INCH_CURRENT based on the new calibration and fixed DPI
                    FEET_PER_INCH_CURRENT = currentDpi / scaleFactorPixelsPerUnit;
                    // Update the scale button text to reflect custom calibration
                    scaleButton.textContent = `Scale: Custom (${FEET_PER_INCH_CURRENT.toFixed(2)} ft/inch)`;
                    outputDisplay.innerText = `Scale calibrated! 1 inch = ${FEET_PER_INCH_CURRENT.toFixed(2)} feet (DPI: ${currentDpi}).`;

                    // Add calibration as a measurement
                    measurements.push({
                        id: Date.now() + '-calibration',
                        type: 'calibration',
                        points: currentDrawing.points,
                        value: `${realWorldLength.toFixed(2)} ft (1 inch = ${FEET_PER_INCH_CURRENT.toFixed(2)} ft, DPI = ${currentDpi}).`,
                        color: currentColor, // Save current color
                        lineStyle: currentLineStyle // Save current line style
                    });
                    saveState(); // Save state after calibration

                } else {
                    outputDisplay.innerText = 'Invalid length entered. Calibration cancelled.';
                }
            } else {
                outputDisplay.innerText = 'Please draw a calibration line first (two clicks).';
            }
            currentDrawing = null; // Clear current drawing after confirmation attempt
            confirmCalibrationBtn.style.display = 'none'; // Hide confirm button
            mode = 'pan'; // Reset mode to pan
            updateModeButtons(); // Update button highlighting
            renderMeasurementsList(); // Update measurements list
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair cursor
        });

        /**
         * Exports the current canvas content as a PNG image.
         */
        function exportCanvasAsPng() {
            if (!imgLoaded) {
                outputDisplay.innerText = 'No image or PDF loaded to export.';
                return;
            }

            // Create a temporary canvas to draw the current state without UI elements
            const tempExportCanvas = document.createElement('canvas');
            const tempExportCtx = tempExportCanvas.getContext('2d');

            // Set the temporary canvas dimensions to match the current visible content area
            // This ensures the exported image is not excessively large or cropped incorrectly.
            // For simplicity, we'll use the mainCanvas's current client dimensions, scaled by DPR.
            tempExportCanvas.width = mainCanvas.clientWidth * dpr;
            tempExportCanvas.height = mainCanvas.clientHeight * dpr;

            // Draw the content from the main canvas onto the temporary canvas
            // Use drawImage to copy the current visual state, including transforms
            tempExportCtx.drawImage(mainCanvas, 0, 0, tempExportCanvas.width, tempExportCanvas.height);

            // Get the image data URL from the temporary canvas
            const imageDataURL = tempExportCanvas.toDataURL('image/png');

            // Create a temporary link element for downloading
            const link = document.createElement('a');
            link.href = imageDataURL;
            link.download = 'measurements_export.png'; // Suggested filename
            document.body.appendChild(link); // Append to body (required for Firefox)
            link.click(); // Programmatically click the link to trigger download
            document.body.removeChild(link); // Clean up the link element
            tempExportCanvas.remove(); // Clean up the temporary canvas

            outputDisplay.innerText = 'Canvas exported as PNG.';
        }

        /**
         * Exports the current measurements data as a CSV file.
         *
         */
        function exportMeasurementsAsCsv() {
            if (measurements.length === 0) {
                outputDisplay.innerText = 'No measurements to export.';
                return;
            }

            // Prepare CSV header and content
            let csvContent = "Type,Value,Text,Count,Radius(ft),AreaSqFt,AreaShotok,Points,Color,LineStyle\n";
            measurements.forEach(m => {
                const type = m.type;
                const value = m.value || '';
                const text = m.text ? `"${m.text.replace(/"/g, '""')}"` : '';
                const count = ''; // Removed count, so it's always empty
                const radius = m.radius !== undefined ? m.radius.toFixed(2) : '';
                const areaSqFt = m.areaSqFt !== undefined ? m.areaSqFt.toFixed(2) : '';
                const areaShotok = m.areaShotok !== undefined ? m.areaShotok.toFixed(4) : '';
                const points = m.points.map(p => `(${p.x.toFixed(2)},${p.y.toFixed(2)})`).join(';');
                const color = m.color || ''; // Export color
                const lineStyle = m.lineStyle || ''; // Export line style
                csvContent += `${type},"${value}",${text},"${count}","${radius}","${areaSqFt}","${areaShotok}","${points}","${color}","${lineStyle}"\n`;
            });

            // Create a Blob and download as CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'measurements.csv'); // File name for download
            link.click(); // Programmatically click the link to trigger download
            outputDisplay.innerText = 'Measurements exported to CSV.';
        }

        // Event listener for "Export" button (now shows modal)
        exportBtn.addEventListener('click', () => {
            if (!imgLoaded && measurements.length === 0) {
                outputDisplay.innerText = 'Nothing to export. Load an image/PDF or draw measurements first.';
                return;
            }
            exportModal.classList.add('show'); // Show the modal
        });

        // Event listeners for modal buttons
        exportCsvOptionBtn.addEventListener('click', () => {
            exportMeasurementsAsCsv();
            exportModal.classList.remove('show'); // Hide the modal
        });

        exportPngOptionBtn.addEventListener('click', () => {
            exportCanvasAsPng();
            exportModal.classList.remove('show'); // Hide the modal
        });

        // Event listeners for drawing tool buttons
        // Added a function to reset drawing state when a new tool is selected
        function resetDrawingState() {
            if (currentDrawing && (mode === 'polygon' || mode === 'angle' || mode === 'circle' || mode === 'calibrate')) {
                currentDrawing = null;
                outputDisplay.innerText = 'Previous drawing cancelled.';
            }
            confirmCalibrationBtn.style.display = 'none'; // Always hide confirm button on tool change
            magnifierDiv.style.display = 'none'; // Always hide magnifier on tool change
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
        }

        drawLineBtn.addEventListener('click', () => {
            resetDrawingState(); // Reset any ongoing drawing
            mode = 'line';
            outputDisplay.innerText = 'Click and drag to draw a line.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawRectangleBtn.addEventListener('click', () => {
            resetDrawingState(); // Reset any ongoing drawing
            mode = 'rectangle';
            outputDisplay.innerText = 'Click and drag to draw a rectangle.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawPolygonBtn.addEventListener('click', () => {
            resetDrawingState(); // Reset any ongoing drawing
            mode = 'polygon';
            currentDrawing = { type: 'polygon', points: [], closed: false }; // Start new polygon
            outputDisplay.innerText = 'Click to add points for polygon. Double-click to finish.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawAngleBtn.addEventListener('click', () => {
            resetDrawingState(); // Reset any ongoing drawing
            mode = 'angle';
            currentDrawing = null; // Start new angle
            outputDisplay.innerText = '1: End of first arm. 2: Vertex. 3: End of second arm.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawCircleBtn.addEventListener('click', () => {
            resetDrawingState(); // Reset any ongoing drawing
            mode = 'circle';
            currentDrawing = null; // Start new circle
            outputDisplay.innerText = '1: Circle center. 2: Radius point.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        addTextBtn.addEventListener('click', () => {
            resetDrawingState(); // Reset any ongoing drawing
            mode = 'text';
            currentDrawing = null; // Text is single click, but clear any previous temp drawing
            outputDisplay.innerText = 'Click on canvas to add a text note.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });

        // Scale Button and Dropdown Logic
        scaleButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent click from immediately closing dropdown
            scaleDropdown.classList.toggle('hidden');
        });

        scaleDropdown.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const selectedScale = e.target.dataset.scale;
                updateScaleValues(selectedScale);
                scaleDropdown.classList.add('hidden'); // Hide dropdown after selection
            }
        });

        // Close dropdown if clicked outside
        window.addEventListener('click', (event) => {
            if (!scaleButton.contains(event.target) && !scaleDropdown.contains(event.target)) {
                scaleDropdown.classList.add('hidden');
            }
        });


        // Event listeners for style options (Line Width, Font Size, Color, Line Style)
        lineWidthInput.addEventListener('input', redraw);
        fontSizeInput.addEventListener('input', redraw);
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            redraw();
        });
        lineStyleSelect.addEventListener('change', (e) => {
            currentLineStyle = e.target.value;
            redraw();
        });


        // Event listener for "Undo" button
        undoBtn.addEventListener('click', () => {
            if (historyPointer > 0) {
                loadState(historyPointer - 1);
                outputDisplay.innerText = 'Last change undone.';
            } else {
                outputDisplay.innerText = 'No changes to undo.';
            }
        });

        // Event listener for "Redo" button
        redoBtn.addEventListener('click', () => {
            if (historyPointer < measurementHistory.length - 1) {
                loadState(historyPointer + 1);
                outputDisplay.innerText = 'Last change redone.';
            } else {
                outputDisplay.innerText = 'No changes to redo.';
            }
        });

        // Event listener for "Reset All" button
        resetAllBtn.addEventListener('click', () => {
            measurements = []; // Clear all measurements
            zoom = 1; // Reset zoom level
            pan = { x: 0, y: 0 }; // Reset pan position
            imgLoaded = false; // Mark image/PDF as not loaded
            img.src = ''; // Clear image source
            currentPdfPage = null; // Clear PDF page reference
            outputDisplay.innerText = 'Canvas reset. Load an image or PDF and start measuring.';
            mode = 'pan'; // Reset mode to pan
            currentDrawing = null; // Clear any partial drawing
            counterValue = 1; // Reset counter
            measurementHistory = []; // Clear history on full reset
            historyPointer = -1; // Reset history pointer
            updateUndoRedoButtons(); // Update button state
            updateModeButtons(); // Update button highlighting
            renderMeasurementsList(); // Clear the measurements list in the sidebar
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair cursor
            confirmCalibrationBtn.style.display = 'none'; // Hide confirm button

            // Reset scale to default
            updateScaleValues('16inch=1mile');
        });

        // Event listener for deleting and editing individual measurements from the sidebar list
        measurementsListDiv.addEventListener('click', (e) => {
            // Check if a delete button was clicked
            if (e.target.tagName === 'BUTTON' && e.target.classList.contains('delete-btn')) {
                const indexToRemove = parseInt(e.target.dataset.index);
                if (indexToRemove >= 0 && indexToRemove < measurements.length) {
                    measurements.splice(indexToRemove, 1); // Remove the measurement from the array
                    outputDisplay.innerText = 'Measurement deleted.';
                    renderMeasurementsList(); // Re-render the list to update display
                    saveState(); // Save state after deletion
                }
            } else if (e.target.tagName === 'BUTTON' && e.target.classList.contains('edit-btn')) { // Check if an edit button was clicked
                const indexToEdit = parseInt(e.target.dataset.index);
                const measurementToEdit = measurements[indexToEdit];

                if (measurementToEdit && measurementToEdit.type === 'text') {
                    const newText = prompt("Edit text note:", measurementToEdit.text);
                    if (newText !== null) {
                        measurementToEdit.text = newText.trim();
                        outputDisplay.innerText = 'Text note updated.';
                        renderMeasurementsList(); // Re-render the list to update display
                        redraw(); // Redraw canvas to reflect text change
                        saveState(); // Save state after edit
                    } else {
                        outputDisplay.innerText = 'Text note cancelled.';
                    }
                }
            }
        });

        /**
         * Updates the visual style (highlighting) of mode buttons based on the current active mode.
         */
        function updateModeButtons() {
            const allDrawButtons = [
                drawLineBtn, drawRectangleBtn, drawPolygonBtn,
                drawAngleBtn, drawCircleBtn, addTextBtn,
                calibrateScaleBtn
            ];
            allDrawButtons.forEach(btn => {
                // Remove active (600) classes and re-add default (500) classes
                btn.classList.remove(
                    'bg-green-600', 'bg-purple-600', 'bg-indigo-600',
                    'bg-pink-600', 'bg-orange-600', 'bg-teal-600', 'bg-cyan-600', 'bg-gray-600', 'bg-blue-600',
                    'bg-red-600', 'bg-yellow-600'
                );
                // Ensure default 500 class is present for non-active buttons
                if (btn.id.includes('Line')) btn.classList.add('bg-green-500');
                else if (btn.id.includes('Rectangle')) btn.classList.add('bg-purple-500');
                else if (btn.id.includes('Polygon')) btn.classList.add('bg-indigo-500');
                else if (btn.id.includes('Angle')) btn.classList.add('bg-pink-500');
                else if (btn.id.includes('Circle')) btn.classList.add('bg-orange-500');
                else if (btn.id.includes('Text')) btn.classList.add('bg-teal-500');
                else if (btn.id.includes('Calibrate')) btn.classList.add('bg-blue-500');
                else btn.classList.add('bg-gray-500'); // Fallback
            });

            // Highlight the currently active mode button
            const activeColor = {
                'pan': '', // No highlight for pan mode button
                'calibrate': 'bg-blue-600',
                'line': 'bg-green-600',
                'rectangle': 'bg-purple-600',
                'polygon': 'bg-indigo-600',
                'angle': 'bg-pink-600',
                'circle': 'bg-orange-600',
                'text': 'bg-teal-600'
            };
            if (mode !== 'pan') {
                let activeButton;
                if (mode === 'text') {
                    activeButton = addTextBtn;
                } else if (mode === 'calibrate') {
                    activeButton = calibrateScaleBtn;
                } else if (mode === 'line') {
                    activeButton = drawLineBtn;
                } else if (mode === 'rectangle') {
                    activeButton = drawRectangleBtn;
                } else if (mode === 'polygon') {
                    activeButton = drawPolygonBtn;
                } else if (mode === 'angle') {
                    activeButton = drawAngleBtn;
                } else if (mode === 'circle') {
                    activeButton = drawCircleBtn;
                }

                if (activeButton) {
                    // Remove current 500 version and add the 600 version for highlighting
                    const baseClass = activeColor[mode].replace('600', '500');
                    if (activeButton.classList.contains(baseClass)) {
                        activeButton.classList.remove(baseClass);
                    }
                    activeButton.classList.add(activeColor[mode]);
                }
            }
        }

        // --- Sidebar Toggle Logic ---
        toggleSidebarBtn.addEventListener('click', () => {
            measurementsSidebar.classList.toggle('collapsed');
            const h3Element = measurementsSidebar.querySelector('.sidebar-header h3');
            if (measurementsSidebar.classList.contains('collapsed')) {
                h3Element.style.display = 'none'; // Hide text when collapsed
            } else {
                h3Element.style.display = 'block'; // Show text when expanded
            }
        });


        // Attach main canvas event listeners for mouse/touch interactions
        mainCanvas.addEventListener('pointerdown', handlePointerDown);
        mainCanvas.addEventListener('pointermove', handlePointerMove);
        mainCanvas.addEventListener('pointerup', handlePointerUp);
        mainCanvas.addEventListener('wheel', handleWheel, { passive: false }); // Use passive: false to allow preventDefault
        mainCanvas.addEventListener('touchstart', handleTouchStart, { passive: false }); // Use passive: false for custom touch handling
        mainCanvas.addEventListener('touchmove', handleTouchMove, { passive: false }); // Use passive: false
        mainCanvas.addEventListener('touchend', handleTouchEnd);
        mainCanvas.addEventListener('dblclick', handleDoubleClick); // For polygon finalization

        // Handle window resize events to adjust canvas and content positioning
        window.addEventListener('resize', () => {
            if (imgLoaded) {
                // Adjust pan to keep the center of the image/PDF visible as much as possible
                // This recalculation helps maintain the view when the window resizes
                pan = {
                    x: (mainCanvas.clientWidth - (img.width * zoom)) / 2,
                    y: (mainCanvas.clientHeight - (img.height * zoom)) / 2,
                };
                    // If a PDF is loaded, re-render it to adapt to new canvas size for clarity
                    // This re-rendering ensures the PDF remains crisp on resize.
                if (currentPdfPage) {
                    const desiredPpi = currentDpi; // Use fixed DPI for PDF rendering
                    const scale = desiredPpi / 72;
                    const renderViewport = currentPdfPage.getViewport({ scale: scale });

                    const offscreenCanvas = document.createElement('canvas');
                    const offscreenCtx = offscreenCanvas.getContext('2d');
                    offscreenCanvas.width = renderViewport.width;
                    offscreenCanvas.height = renderViewport.height;

                    const renderContext = {
                        canvasContext: offscreenCtx,
                        viewport: renderViewport,
                    };
                    currentPdfPage.render(renderContext).promise.then(() => {
                        img.src = offscreenCanvas.toDataURL('image/png'); // Update the main img object
                        offscreenCanvas.remove();
                        redraw(); // Request a full redraw after PDF re-render
                    });
                }
            }
            renderMeasurementsList(); // Re-render list
        });
        window.addEventListener('orientationchange', () => {
            // Similar logic for orientation change on mobile devices
            if (imgLoaded) {
                pan = {
                    x: (mainCanvas.clientWidth - (img.width * zoom)) / 2,
                    y: (mainCanvas.clientHeight - (img.height * zoom)) / 2,
                };
                    // If a PDF is loaded, re-render it to adapt to new canvas size for clarity
                    // This re-rendering ensures the PDF remains crisp on resize.
                if (currentPdfPage) {
                    const desiredPpi = currentDpi; // Use fixed DPI for PDF rendering
                    const scale = desiredPpi / 72;
                    const renderViewport = currentPdfPage.getViewport({ scale: scale });

                    const offscreenCanvas = document.createElement('canvas');
                    const offscreenCtx = offscreenCanvas.getContext('2d');
                    offscreenCanvas.width = renderViewport.width;
                    offscreenCanvas.height = renderViewport.height;

                    const renderContext = {
                        canvasContext: offscreenCtx,
                        viewport: renderViewport,
                    };
                    currentPdfPage.render(renderContext).promise.then(() => {
                        img.src = offscreenCanvas.toDataURL('image/png'); // Update the main img object
                        offscreenCanvas.remove();
                        redraw(); // Request a full redraw after PDF re-render
                    });
                }
            }
            renderMeasurementsList();
        });

        // Initial rendering of the measurement list when the page loads
        renderMeasurementsList();
        updateUndoRedoButtons(); // Initialize button states
        updateScaleValues(currentScaleSetting); // Set initial default scale

        // Start the animation loop. This ensures continuous redrawing for dynamic elements.
        requestAnimationFrame(redraw);

        // WhatsApp Contact Button event listener (moved here to be within the tool's script)
        document.getElementById('whatsappContact').addEventListener('click', () => {
            const phoneNumber = '8801738724260'; // আপনার বিকাশ নম্বরের সাথে যুক্ত হোয়াটসঅ্যাপ নম্বর
            const message = 'আমি Noksha Tool by Tofazzal এর সাবস্ক্রিপশন নিতে আগ্রহী।';
            // Check if electronAPI is defined before calling
            if (window.electronAPI && window.electronAPI.openWhatsApp) {
                window.electronAPI.openWhatsApp(phoneNumber, message);
            } else {
                console.error("electronAPI.openWhatsApp is not available. Preload script issue?");
                // Fallback for web version or if Electron API is not available
                window.open(`https://wa.me/${phoneNumber}?text=${encodeURIComponent(message)}`, '_blank');
            }
        });
        
        // Task 1: Add event listener for the new DPI input
        const dpiInput = document.getElementById('dpiInput');
        dpiInput.addEventListener('input', (e) => {
            const newDpi = parseInt(e.target.value, 10);
            if (!isNaN(newDpi) && newDpi > 0) {
                currentDpi = newDpi;
                // Recalculate everything based on the new DPI
                // We can call updateScaleValues with the current setting to trigger recalculation
                updateScaleValues(currentScaleSetting);
                outputDisplay.innerText = `DPI updated to ${currentDpi}. Measurements recalculated.`;
            }
        });
    </script>
</body>
</html>
