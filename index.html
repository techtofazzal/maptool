<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map Measurement Tool By Tofazzal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent body scroll */
        }
        #toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px; /* Reduced gap between buttons */
            padding: 8px; /* Reduced padding */
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }
        #toolbar button, #toolbar input[type="file"], #toolbar select {
            padding: 6px 12px; /* Smaller padding for buttons */
            font-size: 0.8rem; /* Slightly smaller font size for buttons */
            border-radius: 9999px; /* Full rounded corners */
        }
        #toolbar label input[type="number"],
        #toolbar label input[type="range"] {
            padding: 4px 8px; /* Smaller padding for inputs */
            font-size: 0.8rem;
            border-radius: 9999px; /* Full rounded corners */
        }

        #main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #canvas-container {
            position: relative;
            flex-grow: 1;
            background: #e2e8f0; /* Tailwind gray-200 */
            overflow: hidden;
            touch-action: none; /* Disable default touch actions for custom handling */
            cursor: default; /* Default cursor for pan mode */
        }
        #canvas-container.drawing-mode {
            cursor: crosshair; /* Crosshair cursor for drawing modes */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #f8fafc; /* Tailwind gray-50 */
            touch-action: none;
        }
        .magnifier {
            position: absolute;
            /* No fixed top/right, will be positioned by JS */
            width: 150px;
            height: 150px;
            border: 2px solid #3b82f6; /* Blue-500 */
            border-radius: 8px; /* Rounded corners */
            overflow: hidden;
            pointer-events: none; /* Allow events to pass through */
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); /* Soft shadow */
            background-color: white; /* Fallback for transparency */
            display: none; /* Hidden by default */
        }
        #measurements-sidebar {
            width: 300px;
            background: #f1f5f9; /* Tailwind gray-100 */
            padding: 10px;
            overflow-y: auto;
            box-shadow: -2px 0 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
        }
        .measurement-item {
            background: white;
            padding: 8px;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem; /* text-sm */
        }
        .measurement-item button {
            background: #ef4444; /* Red-500 */
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background-color 0.2s;
        }
        .measurement-item button:hover {
            background: #dc2626; /* Red-600 */
        }
        #output {
            padding: 10px;
            background: white;
            text-align: center;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div id="toolbar">
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Load Image:
            <input
                type="file"
                id="imageLoader"
                accept="image/*"
                class="block w-full text-sm text-gray-500 file:mr-4 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"
            />
        </label>

        <!-- New Scale Inputs -->
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            DPI:
            <input type="number" id="dpiInput" value="400" min="1" class="w-16 px-2 py-1 rounded-full text-sm bg-gray-200" />
        </label>
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Feet/Inch:
            <input type="number" id="feetPerInchInput" value="330" min="0.1" step="0.1" class="w-16 px-2 py-1 rounded-full text-sm bg-gray-200" />
        </label>
        <!-- End New Scale Inputs -->

        <button
            id="drawLineBtn"
            class="bg-green-500 text-white hover:bg-green-600 transition-colors duration-200"
        >
            Draw Line
        </button>

        <button
            id="drawRectangleBtn"
            class="bg-purple-500 text-white hover:bg-purple-600 transition-colors duration-200"
        >
            Draw Rectangle
        </button>

        <button
            id="drawPolygonBtn"
            class="bg-indigo-500 text-white hover:bg-indigo-600 transition-colors duration-200"
        >
            Draw Polygon
        </button>
        
        <button
            id="drawAngleBtn"
            class="bg-pink-500 text-white hover:bg-pink-600 transition-colors duration-200"
        >
            Draw Angle
        </button>

        <button
            id="drawCircleBtn"
            class="bg-orange-500 text-white hover:bg-orange-600 transition-colors duration-200"
        >
            Draw Circle
        </button>

        <button
            id="addTextBtn"
            class="bg-teal-500 text-white hover:bg-teal-600 transition-colors duration-200"
        >
            Add Text Note
        </button>

        <button
            id="addCounterBtn"
            class="bg-cyan-500 text-white hover:bg-cyan-600 transition-colors duration-200"
        >
            Add Counter
        </button>

        <button
            id="freehandBtn"
            class="bg-gray-500 text-white hover:bg-gray-600 transition-colors duration-200"
        >
            Freehand Draw
        </button>

        <span class="px-3 py-1 rounded-full text-sm font-semibold bg-gray-200 text-gray-700 border border-gray-300 shadow-sm">
            Unit: ft (Feet)
        </span>

        <!-- Style Options -->
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Line Width:
            <input type="range" id="lineWidthInput" min="1" max="10" value="2" class="w-20" />
        </label>
        <!-- Line Style option removed -->
        <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
            Font Size:
            <input type="range" id="fontSizeInput" min="10" max="30" value="14" class="w-20" />
        </label>
        <!-- Show Arrows checkbox removed -->


        <!-- Save/Load/Export buttons removed as per request -->
        <button
            id="exportCsvBtn"
            class="bg-gray-600 text-white hover:bg-gray-700 transition-colors duration-200"
        >
            Export CSV
        </button>

        <button
            id="undoLastBtn"
            class="bg-yellow-500 text-white hover:bg-yellow-600 transition-colors duration-200"
        >
            Undo Last
        </button>

        <button
            id="resetAllBtn"
            class="bg-red-500 text-white hover:bg-red-600 transition-colors duration-200"
        >
            Reset All
        </button>
    </div>

    <!-- Main Content Area (Canvas + Sidebar) -->
    <div id="main-content">
        <!-- Canvas Container -->
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <!-- Magnifier Canvas -->
            <div id="magnifier" class="magnifier">
                <canvas id="magnifierCanvas"></canvas>
            </div>
        </div>

        <!-- Measurements Sidebar -->
        <div id="measurements-sidebar">
            <h3 class="text-lg font-bold mb-2">Current Measurements</h3>
            <div id="measurementsList" class="flex flex-col gap-2">
                <!-- Measurements will be listed here -->
            </div>
        </div>
    </div>

    <!-- Output / Message Bar -->
    <div id="output">
        Load an image and start measuring.
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        const imageLoader = document.getElementById('imageLoader');
        const drawLineBtn = document.getElementById('drawLineBtn');
        const drawRectangleBtn = document.getElementById('drawRectangleBtn');
        const drawPolygonBtn = document.getElementById('drawPolygonBtn');
        const drawAngleBtn = document.getElementById('drawAngleBtn');
        const drawCircleBtn = document.getElementById('drawCircleBtn');
        const addTextBtn = document.getElementById('addTextBtn');
        const addCounterBtn = document.getElementById('addCounterBtn');
        const freehandBtn = document.getElementById('freehandBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const undoLastBtn = document.getElementById('undoLastBtn');
        const resetAllBtn = document.getElementById('resetAllBtn');
        const outputDisplay = document.getElementById('output');
        const magnifierDiv = document.getElementById('magnifier');
        const magnifierCanvas = document.getElementById('magnifierCanvas');
        const magnifyCtx = magnifierCanvas.getContext('2d');
        const measurementsListDiv = document.getElementById('measurementsList');
        const canvasContainer = document.getElementById('canvas-container');

        const dpiInput = document.getElementById('dpiInput');
        const feetPerInchInput = document.getElementById('feetPerInchInput');
        const lineWidthInput = document.getElementById('lineWidthInput');
        const fontSizeInput = document.getElementById('fontSizeInput');

        let img = new Image();
        let imgLoaded = false;
        let zoom = 1;
        let pan = { x: 0, y: 0 };
        let isDragging = false;
        let startPoint = { x: 0, y: 0 }; // Screen coords for pan, canvas coords for drawing start
        let currentDrawing = null; // Temporary points for current drawing
        let selectedPoint = null; // { measurementIndex, pointIndex, type } for editing
        let mode = 'pan'; // 'pan', 'line', 'polygon', 'rectangle', 'angle', 'circle', 'text', 'counter', 'freehand'
        let measurements = []; // Stores all drawn measurements
        let counterValue = 1; // For the counter tool

        const unit = 'ft'; // Unit will always be feet
        
        // Scale factors (dynamically updated from UI inputs)
        let PIXELS_PER_INCH_CURRENT = parseFloat(dpiInput.value);
        let FEET_PER_INCH_CURRENT = parseFloat(feetPerInchInput.value);
        let scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT; // Pixels per foot (dynamic)

        const HIT_RADIUS = 4; // Pixels for detecting points (further reduced for smaller blue circles)
        const MAGNIFIER_SIZE = 150; // Size of the magnifier square
        const MAGNIFIER_ZOOM = 3; // How much the magnifier zooms in

        // Get device pixel ratio for high-DPI screens
        const dpr = window.devicePixelRatio || 1;

        // Set magnifier canvas size
        magnifierCanvas.width = MAGNIFIER_SIZE * dpr;
        magnifierCanvas.height = MAGNIFIER_SIZE * dpr;
        magnifyCtx.scale(dpr, dpr); // Scale magnifier context for DPR

        // Helper: Get canvas context
        function getContext() {
            return mainCanvas.getContext('2d');
        }

        // Helper: Convert screen coordinates to canvas coordinates (considering pan and zoom)
        function getCanvasCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            // clientX/Y are CSS pixels, so they don't need to be multiplied by dpr here.
            // The canvas context itself is scaled by dpr.
            const x = (clientX - rect.left - pan.x) / zoom;
            const y = (clientY - rect.top - pan.y) / zoom;
            return { x, y };
        }

        // Helper: Convert canvas coordinates to screen coordinates
        function getScreenCoords(x, y) {
            const screenX = x * zoom + pan.x;
            const screenY = y * zoom + pan.y;
            return { x: screenX, y: screenY };
        }

        // Helper to draw a circle point
        function drawPoint(context, x, y, currentZoom) {
            context.beginPath();
            context.arc(x, y, (HIT_RADIUS / 2) / currentZoom, 0, Math.PI * 2); // Radius scales inversely with zoom
            context.fill();
        }

        // Draw Arrowhead (logic still exists, but not used since checkbox removed)
        function drawArrowhead(context, p1, p2, size) {
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            context.save();
            context.translate(p2.x, p2.y);
            context.rotate(angle);
            context.beginPath();
            context.moveTo(-size, -size / 2);
            context.lineTo(0, 0);
            context.lineTo(-size, size / 2);
            context.fill();
            context.restore();
        }

        // Line style is always solid now
        function setLineStyle(context) {
            context.setLineDash([]); // Solid line
        }

        // Calculate length for a line
        function calculateLineLength(p1, p2) {
            const lengthInPixels = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const lengthInFeet = lengthInPixels / scaleFactorPixelsPerUnit;
            const lengthInMeters = lengthInFeet * 0.3048; // 1 foot = 0.3048 meters
            const lengthInLinks = lengthInFeet / 0.66; // 1 link = 0.66 feet
            return `${lengthInFeet.toFixed(2)} ft / ${lengthInLinks.toFixed(2)} links`; // Removed meters as requested
        }

        // Calculate area for a rectangle
        function calculateRectangleArea(p1, p2) {
            const widthPixels = Math.abs(p2.x - p1.x);
            const heightPixels = Math.abs(p2.y - p1.y);
            const widthFeet = widthPixels / scaleFactorPixelsPerUnit;
            const heightFeet = heightPixels / scaleFactorPixelsPerUnit;
            const areaSqFt = widthFeet * heightFeet;
            const areaShotok = areaSqFt / 435.6; // 1 shotok = 435.6 sq ft
            return `${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
        }

        // Calculate area for a polygon (Shoelace formula)
        function calculatePolygonArea(points) {
            if (points.length < 3) return 'N/A';
            let areaPixels = 0;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                areaPixels += (p1.x * p2.y - p2.x * p1.y);
            }
            areaPixels = Math.abs(areaPixels / 2); // Area in pixels²

            const areaSqFt = areaPixels / (scaleFactorPixelsPerUnit * scaleFactorPixelsPerUnit);
            const areaShotok = areaSqFt / 435.6; // 1 shotok = 435.6 sq ft
            return `${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
        }

        // Calculate angle between three points (p1-p2-p3, p2 is vertex)
        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            const magnitude1 = Math.hypot(v1.x, v1.y);
            const magnitude2 = Math.hypot(v2.x, v2.y);

            if (magnitude1 === 0 || magnitude2 === 0) return 'N/A';

            let angleRad = Math.acos(dotProduct / (magnitude1 * magnitude2));
            let angleDeg = angleRad * (180 / Math.PI);
            return `${angleDeg.toFixed(2)}°`;
        }

        // Redraw function
        function redraw() {
            // Set canvas dimensions respecting device pixel ratio
            mainCanvas.width = mainCanvas.clientWidth * dpr;
            mainCanvas.height = mainCanvas.clientHeight * dpr;

            ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

            ctx.save();
            ctx.scale(dpr, dpr); // Scale the context by device pixel ratio
            ctx.translate(pan.x, pan.y);
            ctx.scale(zoom, zoom);

            // Draw image
            if (imgLoaded) {
                ctx.drawImage(img, 0, 0);
            }

            // Apply global line width and font size from UI
            const currentLineWidth = parseFloat(lineWidthInput.value);
            const currentFontSize = parseFloat(fontSizeInput.value);
            const showArrows = false; // Show arrows checkbox removed, always false

            // Draw existing measurements
            measurements.forEach((m) => {
                ctx.strokeStyle = 'red'; // Line color is red
                ctx.lineWidth = currentLineWidth / zoom;
                ctx.fillStyle = 'blue'; // Text and point color is blue
                ctx.font = `${currentFontSize / zoom}px sans-serif`;
                setLineStyle(ctx); // Always solid line

                if (m.type === 'line') {
                    const [p1, p2] = m.points;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    // Arrows are not drawn
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p2.x, p2.y, zoom);
                    if (m.value) {
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        ctx.fillText(m.value, midX + 5 / zoom, midY - 5 / zoom);
                    }
                } else if (m.type === 'rectangle') {
                    const [p1, p2] = m.points; // p1 top-left, p2 bottom-right
                    const c1 = { x: p1.x, y: p1.y };
                    const c2 = { x: p2.x, y: p1.y };
                    const c3 = { x: p2.x, y: p2.y };
                    const c4 = { x: p1.x, y: p2.y };

                    ctx.beginPath();
                    ctx.moveTo(c1.x, c1.y);
                    ctx.lineTo(c2.x, c2.y);
                    ctx.lineTo(c3.x, c3.y);
                    ctx.lineTo(c4.x, c4.y);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; /* Transparent fill: Light gray */
                    ctx.fill();
                    ctx.fillStyle = 'blue'; /* Reset fillStyle for text/points */

                    // Draw segment measurements
                    const segments = [
                        { p1: c1, p2: c2 }, // Top
                        { p1: c2, p2: c3 }, // Right
                        { p1: c3, p2: c4 }, // Bottom
                        { p1: c4, p2: c1 }  // Left
                    ];
                    segments.forEach(seg => {
                        const midX = (seg.p1.x + seg.p2.x) / 2;
                        const midY = (seg.p1.y + seg.p2.y) / 2;
                        const length = calculateLineLength(seg.p1, seg.p2);
                        ctx.fillText(length.split(' / ')[0], midX, midY); // Show only feet length for segments
                    });

                    drawPoint(ctx, c1.x, c1.y, zoom);
                    drawPoint(ctx, c2.x, c2.y, zoom);
                    drawPoint(ctx, c3.x, c3.y, zoom);
                    drawPoint(ctx, c4.x, c4.y, zoom);

                    if (m.value) {
                        // Display area in the center
                        ctx.fillText(m.value, c1.x + (p2.x - p1.x) / 2 - ctx.measureText(m.value).width / 2, c1.y + (p2.y - p1.y) / 2);
                    }
                } else if (m.type === 'polygon') {
                    if (m.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(m.points[0].x, m.points[0].y);
                        for (let i = 1; i < m.points.length; i++) {
                            ctx.lineTo(m.points[i].x, m.points[i].y);
                        }
                        if (m.points.length > 2 && m.closed) {
                            ctx.closePath();
                            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; /* Transparent fill: Light gray */
                            ctx.fill();
                            ctx.fillStyle = 'blue'; /* Reset fillStyle for text/points */
                        }
                        ctx.stroke();

                        // Draw segment measurements
                        for (let i = 0; i < m.points.length; i++) {
                            const p1 = m.points[i];
                            const p2 = m.points[(i + 1) % m.points.length]; // Connect last to first if closed
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const length = calculateLineLength(p1, p2);
                            ctx.fillText(length.split(' / ')[0], midX, midY); // Show only feet length for segments
                        }

                        m.points.forEach(p => drawPoint(ctx, p.x, p.y, zoom));
                        if (m.closed && m.value) {
                            let sumX = 0, sumY = 0;
                            m.points.forEach(p => { sumX += p.x; sumY += p.y; });
                            const centroidX = sumX / m.points.length;
                            const centroidY = sumY / m.points.length;
                            ctx.fillText(m.value, centroidX, centroidY);
                        }
                    }
                } else if (m.type === 'angle') {
                    const [p1, p2, p3] = m.points; // p2 is vertex
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.stroke();
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p2.x, p2.y, zoom);
                    drawPoint(ctx, p3.x, p3.y, zoom);

                    // Draw arc for angle
                    const angleRadius = 30 / zoom;
                    const startAngle = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                    const endAngle = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                    
                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, angleRadius, startAngle, endAngle);
                    ctx.stroke();

                    // Text for angle value near arc
                    const textAngle = (startAngle + endAngle) / 2;
                    const textX = p2.x + Math.cos(textAngle) * (angleRadius + 10 / zoom);
                    const textY = p2.y + Math.sin(textAngle) * (angleRadius + 10 / zoom);
                    ctx.fillText(m.value, textX, textY);

                    // Show arm lengths
                    const len1 = calculateLineLength(p1, p2);
                    const len2 = calculateLineLength(p2, p3);
                    ctx.fillText(len1.split(' / ')[0], (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 - 5 / zoom);
                    ctx.fillText(len2.split(' / ')[0], (p2.x + p3.x) / 2, (p2.y + p3.y) / 2 - 5 / zoom);
                } else if (m.type === 'circle') {
                    const [center, radiusPoint] = m.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    drawPoint(ctx, center.x, center.y, zoom);
                    drawPoint(ctx, radiusPoint.x, radiusPoint.y, zoom);
                    if (m.value) {
                        ctx.fillText(m.value, center.x, center.y - radius - 5 / zoom);
                    }
                    // Show radius length
                    const radiusLength = calculateLineLength(center, radiusPoint);
                    ctx.fillText("Radius: " + radiusLength.split(' / ')[0], (center.x + radiusPoint.x) / 2, (center.y + radiusPoint.y) / 2 - 5 / zoom);
                } else if (m.type === 'text') {
                    ctx.fillStyle = 'blue'; // Text color
                    ctx.font = `${currentFontSize / zoom}px sans-serif`;
                    ctx.fillText(m.text, m.points[0].x, m.points[0].y);
                } else if (m.type === 'counter') {
                    ctx.fillStyle = 'blue'; // Counter color
                    ctx.font = `${currentFontSize / zoom}px sans-serif`;
                    ctx.fillText(m.count, m.points[0].x, m.points[0].y);
                    drawPoint(ctx, m.points[0].x, m.points[0].y, zoom);
                } else if (m.type === 'freehand') {
                    if (m.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(m.points[0].x, m.points[0].y);
                        for (let i = 1; i < m.points.length; i++) {
                            ctx.lineTo(m.points[i].x, m.points[i].y);
                        }
                        ctx.stroke();
                    }
                    if (m.value) { // Display total length
                        // Place text near the start point for freehand
                        const firstPoint = m.points[0];
                        ctx.fillText(m.value, firstPoint.x + 5 / zoom, firstPoint.y - 5 / zoom);
                    }
                }
            });

            // Always solid line for current drawing as well
            setLineStyle(ctx);

            // Draw current drawing (tempLine, tempRect, tempPolygon, tempAngle, tempCircle, freehand)
            if (currentDrawing) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = currentLineWidth / zoom;
                ctx.fillStyle = 'blue';
                ctx.font = `${currentFontSize / zoom}px sans-serif`;

                if (mode === 'line') {
                    const [p1, p2] = currentDrawing.points;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    // Arrows are not drawn
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p2.x, p2.y, zoom);
                } else if (mode === 'rectangle') {
                    const [p1, p2] = currentDrawing.points;
                    const width = p2.x - p1.x;
                    const height = p2.y - p1.y;
                    ctx.strokeRect(p1.x, p1.y, width, height);
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p1.x + width, p1.y, zoom);
                    drawPoint(ctx, p1.x, p1.y + height, zoom);
                    drawPoint(ctx, p1.x + width, p1.y + height, zoom);
                } else if (mode === 'polygon') {
                    if (currentDrawing.points.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                        for (let i = 1; i < currentDrawing.points.length; i++) {
                            ctx.lineTo(currentDrawing.points[i].x, currentDrawing.points[i].y);
                        }
                        // Draw temporary line from last point to current mouse position
                        const mouseCanvasCoords = getCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                        currentDrawing.points.forEach(p => drawPoint(ctx, p.x, p.y, zoom));
                        drawPoint(ctx, mouseCanvasCoords.x, mouseCanvasCoords.y, zoom); // Draw current mouse point
                    }
                } else if (mode === 'angle' && currentDrawing.points.length > 0) {
                    drawPoint(ctx, currentDrawing.points[0].x, currentDrawing.points[0].y, zoom); // First point
                    if (currentDrawing.points.length === 1) { // Drawing first arm
                        const mouseCanvasCoords = getCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.beginPath();
                        ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                        drawPoint(ctx, mouseCanvasCoords.x, mouseCanvasCoords.y, zoom);
                    } else if (currentDrawing.points.length === 2) { // Drawing second arm
                        const [p1, p2] = currentDrawing.points; // p2 is vertex
                        const mouseCanvasCoords = getCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                        drawPoint(ctx, p1.x, p1.y, zoom);
                        drawPoint(ctx, p2.x, p2.y, zoom);
                        drawPoint(ctx, mouseCanvasCoords.x, mouseCanvasCoords.y, zoom);
                    }
                } else if (mode === 'circle' && currentDrawing.points.length > 0) {
                    const [center] = currentDrawing.points;
                    const mouseCanvasCoords = getCanvasCoords(lastPointerClientX, lastPointerClientY);
                    const radius = Math.hypot(mouseCanvasCoords.x - center.x, mouseCanvasCoords.y - center.y);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    drawPoint(ctx, center.x, center.y, zoom);
                    drawPoint(ctx, mouseCanvasCoords.x, mouseCanvasCoords.y, zoom);
                } else if (mode === 'freehand' && currentDrawing.points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                    for (let i = 1; i < currentDrawing.points.length; i++) {
                        ctx.lineTo(currentDrawing.points[i].x, currentDrawing.points[i].y);
                    }
                    ctx.stroke();
                }
            }

            ctx.restore();

            // Draw magnifier content if active
            if (magnifierDiv.style.display === 'block') {
                magnifyCtx.clearRect(0, 0, MAGNIFIER_SIZE * dpr, MAGNIFIER_SIZE * dpr);

                // Get the current pointer position in CSS pixels relative to the main canvas's top-left
                const mainCanvasRect = mainCanvas.getBoundingClientRect();
                const pointerCssX_relativeToCanvas = lastPointerClientX - mainCanvasRect.left;
                const pointerCssY_relativeToCanvas = lastPointerClientY - mainCanvasRect.top;

                // The physical pixel coordinates on the mainCanvas's backing buffer where the cursor is
                const rawPixelX_under_cursor = pointerCssX_relativeToCanvas * dpr;
                const rawPixelY_under_cursor = pointerCssY_relativeToCanvas * dpr;

                // The size of the region to capture from the main canvas (in physical pixels).
                const sourceRegionPhysicalSize = (MAGNIFIER_SIZE / MAGNIFIER_ZOOM) * dpr;

                // Calculate the top-left corner of the source rectangle on the mainCanvas (physical pixels).
                // This rectangle will be centered around the rawPixelX_under_cursor/Y_under_cursor.
                const sourceX_physical = rawPixelX_under_cursor - (sourceRegionPhysicalSize / 2);
                const sourceY_physical = rawPixelY_under_cursor - (sourceRegionPhysicalSize / 2);
                
                magnifyCtx.drawImage(
                    mainCanvas, 
                    sourceX_physical, sourceY_physical, 
                    sourceRegionPhysicalSize, sourceRegionPhysicalSize, 
                    0, 0, MAGNIFIER_SIZE * dpr, MAGNIFIER_SIZE * dpr
                );

                // Draw a crosshair in the center of the magnifier for precise aiming
                magnifyCtx.strokeStyle = 'lime'; // Bright green crosshair
                magnifyCtx.lineWidth = 1 / dpr; // Scale line width by DPR on magnifier
                magnifyCtx.beginPath();
                magnifyCtx.moveTo(MAGNIFIER_SIZE / 2, 0);
                magnifyCtx.lineTo(MAGNIFIER_SIZE / 2, MAGNIFIER_SIZE);
                magnifyCtx.moveTo(0, MAGNIFIER_SIZE / 2);
                magnifyCtx.lineTo(MAGNIFIER_SIZE, MAGNIFIER_SIZE / 2);
                magnifyCtx.stroke();
            }

            requestAnimationFrame(redraw);
        }

        // --- Measurement List Rendering ---
        function renderMeasurementsList() {
            measurementsListDiv.innerHTML = ''; // Clear existing list
            if (measurements.length === 0) {
                measurementsListDiv.innerHTML = '<p class="text-gray-600 text-sm">No measurements yet. Draw something!</p>';
                return;
            }
            measurements.forEach((m, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'measurement-item';
                let displayText = '';
                if (m.type === 'line') {
                    displayText = `Line: ${m.value}`;
                } else if (m.type === 'rectangle') {
                    displayText = `Rect: ${m.value}`;
                } else if (m.type === 'polygon') {
                    displayText = `Poly: ${m.value}`;
                } else if (m.type === 'angle') {
                    displayText = `Angle: ${m.value}`;
                } else if (m.type === 'circle') {
                    displayText = `Circle (R:${m.radius.toFixed(2)}ft): ${m.value}`;
                } else if (m.type === 'text') {
                    displayText = `Text: "${m.text}"`;
                } else if (m.type === 'counter') {
                    displayText = `Counter: ${m.count}`;
                } else if (m.type === 'freehand') {
                    displayText = `Freehand Drawing (Length: ${m.value})`;
                }
                itemDiv.innerHTML = `
                    <span class="text-sm font-medium text-gray-800">${displayText}</span>
                    <button data-index="${index}">Delete</button>
                `;
                measurementsListDiv.appendChild(itemDiv);
            });
        }

        // Track last pointer position for magnifier and temporary line drawing
        let lastPointerClientX = 0;
        let lastPointerClientY = 0;

        // --- Event Handlers ---

        function handlePointerDown(e) {
            if (e.button === 2) return; // Ignore right click

            const { x, y } = getCanvasCoords(e.clientX, e.clientY);
            startPoint = { clientX: e.clientX, clientY: e.clientY, x, y };
            isDragging = true;
            
            // For magnifier positioning
            lastPointerClientX = e.clientX;
            lastPointerClientY = e.clientY;

            if (mode === 'pan') {
                magnifierDiv.style.display = 'none'; // Hide magnifier in pan mode
            } else if (mode === 'line') {
                currentDrawing = { type: 'line', points: [{ x, y }, { x, y }] };
                magnifierDiv.style.display = 'block';
            } else if (mode === 'rectangle') {
                currentDrawing = { type: 'rectangle', points: [{ x, y }, { x, y }] };
                magnifierDiv.style.display = 'block';
            } else if (mode === 'polygon') {
                if (!currentDrawing || currentDrawing.points.length === 0) { // Starting new polygon
                    currentDrawing = { type: 'polygon', points: [{ x, y }], closed: false };
                } else { // Adding point to existing polygon
                    currentDrawing.points.push({ x, y });
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'angle') {
                if (!currentDrawing) {
                    currentDrawing = { type: 'angle', points: [{ x, y }] }; // First point (arm 1 end)
                } else if (currentDrawing.points.length === 1) {
                    currentDrawing.points.push({ x, y }); // Second point (vertex)
                } else if (currentDrawing.points.length === 2) {
                    currentDrawing.points.push({ x, y }); // Third point (arm 2 end)
                    const [p1, p2, p3] = currentDrawing.points;
                    measurements.push({
                        id: Date.now() + '-angle',
                        type: 'angle',
                        points: currentDrawing.points,
                        value: calculateAngle(p1, p2, p3)
                    });
                    outputDisplay.innerText = 'Angle drawn. Value: ' + measurements[measurements.length - 1].value;
                    currentDrawing = null;
                    magnifierDiv.style.display = 'none';
                    mode = 'pan'; // Reset mode
                    updateModeButtons();
                    renderMeasurementsList();
                    canvasContainer.classList.remove('drawing-mode');
                    return; // Exit to prevent further processing as measurement is complete
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'circle') {
                if (!currentDrawing) {
                    currentDrawing = { type: 'circle', points: [{ x, y }] }; // First point (center)
                } else if (currentDrawing.points.length === 1) {
                    currentDrawing.points.push({ x, y }); // Second point (radius point)
                    const [center, radiusPoint] = currentDrawing.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                    const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                    const areaShotok = areaSqFt / 435.6;

                    measurements.push({
                        id: Date.now() + '-circle',
                        type: 'circle',
                        points: currentDrawing.points,
                        radius: radius / scaleFactorPixelsPerUnit, // Radius in feet
                        value: `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`
                    });
                    outputDisplay.innerText = 'Circle drawn. ' + measurements[measurements.length - 1].value;
                    currentDrawing = null;
                    magnifierDiv.style.display = 'none';
                    mode = 'pan'; // Reset mode
                    updateModeButtons();
                    renderMeasurementsList();
                    canvasContainer.classList.remove('drawing-mode');
                    return; // Exit as measurement is complete
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'text') {
                const textInput = prompt("Enter text for the note:");
                if (textInput !== null && textInput.trim() !== '') {
                    measurements.push({
                        id: Date.now() + '-text',
                        type: 'text',
                        points: [{ x, y }],
                        text: textInput.trim()
                    });
                    outputDisplay.innerText = 'Text note added.';
                    renderMeasurementsList();
                } else {
                    outputDisplay.innerText = 'Text note cancelled.';
                }
                magnifierDiv.style.display = 'none';
                mode = 'pan'; // Reset mode after placing text
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                return;
            } else if (mode === 'counter') {
                measurements.push({
                    id: Date.now() + '-counter',
                    type: 'counter',
                    points: [{ x, y }],
                    count: counterValue++ // Use and increment global counter
                });
                outputDisplay.innerText = `Counter ${counterValue - 1} added.`;
                renderMeasurementsList();
                magnifierDiv.style.display = 'none';
                mode = 'pan'; // Reset mode after placing counter
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                return;
            } else if (mode === 'freehand') {
                currentDrawing = { type: 'freehand', points: [{ x, y }] };
                magnifierDiv.style.display = 'block';
            }

            // Check for point selection for editing existing measurements (only in pan mode or if no drawing in progress)
            if (mode === 'pan' || !currentDrawing) {
                selectedPoint = null;
                measurements.forEach((m, measIdx) => {
                    m.points.forEach((p, pIdx) => {
                        const screenP = getScreenCoords(p.x, p.y);
                        // Check if pointer is within HIT_RADIUS (in CSS pixels) of the rendered point
                        if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < HIT_RADIUS) {
                            selectedPoint = { measurementIndex: measIdx, pointIndex: pIdx, type: m.type };
                            currentDrawing = null; // Ensure no new drawing starts if editing
                            magnifierDiv.style.display = 'block';
                            return;
                        }
                    });
                });
            }
        }

        function handlePointerMove(e) {
            lastPointerClientX = e.clientX;
            lastPointerClientY = e.clientY;

            // Position the magnifier DIV so its center is at the current pointer location
            if (magnifierDiv.style.display === 'block') {
                magnifierDiv.style.left = `${e.clientX - (MAGNIFIER_SIZE / 2)}px`;
                magnifierDiv.style.top = `${e.clientY - (MAGNIFIER_SIZE / 2)}px`;
            }

            const { x: currentCanvasX, y: currentCanvasY } = getCanvasCoords(e.clientX, e.clientY);

            if (selectedPoint) {
                // Editing an existing measurement's point
                const meas = measurements[selectedPoint.measurementIndex];

                if (selectedPoint.type === 'line') {
                    meas.points[selectedPoint.pointIndex] = { x: currentCanvasX, y: currentCanvasY };
                    meas.value = calculateLineLength(meas.points[0], meas.points[1]);
                } else if (selectedPoint.type === 'rectangle') {
                    const [p1, p2] = meas.points;
                    if (selectedPoint.pointIndex === 0) { // Dragging top-left
                        meas.points = [{ x: currentCanvasX, y: currentCanvasY }, p2];
                    } else if (selectedPoint.pointIndex === 1) { // Dragging bottom-right
                        meas.points = [p1, { x: currentCanvasX, y: currentCanvasY }];
                    }
                    meas.value = calculateRectangleArea(meas.points[0], meas.points[1]);
                } else if (selectedPoint.type === 'polygon' || selectedPoint.type === 'angle' || selectedPoint.type === 'circle') {
                    meas.points[selectedPoint.pointIndex] = { x: currentCanvasX, y: currentCanvasY };
                    if (selectedPoint.type === 'polygon') {
                        meas.value = calculatePolygonArea(meas.points);
                    } else if (selectedPoint.type === 'angle') {
                        const [p1, p2, p3] = meas.points;
                        meas.value = calculateAngle(p1, p2, p3);
                    } else if (selectedPoint.type === 'circle') {
                        const [center, radiusPoint] = meas.points;
                        const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                        const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                        const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                        const areaShotok = areaSqFt / 435.6;
                        meas.radius = radius / scaleFactorPixelsPerUnit; // Update radius in feet
                        meas.value = `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
                    }
                } else if (selectedPoint.type === 'text' || selectedPoint.type === 'counter') {
                    meas.points[selectedPoint.pointIndex] = { x: currentCanvasX, y: currentCanvasY };
                } else if (selectedPoint.type === 'freehand') {
                    // Freehand points are not moved individually after drawing
                }
                outputDisplay.innerText = 'Editing measurement...';
                renderMeasurementsList(); // Update list after editing
            } else if (mode === 'pan' && isDragging) {
                // Panning the canvas
                pan.x += (e.clientX - startPoint.clientX);
                pan.y += (e.clientY - startPoint.clientY);
                startPoint.clientX = e.clientX;
                startPoint.clientY = e.clientY;
            } else if (currentDrawing && isDragging && (mode === 'line' || mode === 'rectangle' || mode === 'freehand')) {
                // Drawing a new measurement (line, rectangle, or freehand)
                if (mode === 'line' || mode === 'rectangle') {
                    currentDrawing.points[1] = { x: currentCanvasX, y: currentCanvasY };
                } else if (mode === 'freehand') {
                    currentDrawing.points.push({ x: currentCanvasX, y: currentCanvasY });
                }
            }
            // For polygon, angle, circle: temporary lines/shapes are drawn in redraw based on currentDrawing and mouse position
        }


        function handlePointerUp() {
            isDragging = false;
            selectedPoint = null; // Clear selected point after release
            magnifierDiv.style.display = 'none'; // Deactivate magnifier on pointer up

            if (currentDrawing) {
                if (mode === 'line') {
                    const line = {
                        id: Date.now() + '-line',
                        type: 'line',
                        points: currentDrawing.points,
                        value: calculateLineLength(currentDrawing.points[0], currentDrawing.points[1])
                    };
                    measurements.push(line);
                    outputDisplay.innerText = 'Line drawn. Length: ' + line.value;
                } else if (mode === 'rectangle') {
                    const rect = {
                        id: Date.now() + '-rect',
                        type: 'rectangle',
                        points: currentDrawing.points,
                        value: calculateRectangleArea(currentDrawing.points[0], currentDrawing.points[1])
                    };
                    measurements.push(rect);
                    outputDisplay.innerText = 'Rectangle drawn. Area: ' + rect.value;
                } else if (mode === 'freehand') {
                    if (currentDrawing.points.length > 1) { // Only save if more than one point
                        // Calculate total length for freehand path
                        let totalLength = 0;
                        for(let i = 0; i < currentDrawing.points.length - 1; i++) {
                            const p1 = currentDrawing.points[i];
                            const p2 = currentDrawing.points[i+1];
                            totalLength += Math.hypot(p2.x - p1.x, p2.y - p1.y);
                        }
                        const lengthInFeet = totalLength / scaleFactorPixelsPerUnit;
                        const lengthInMeters = lengthInFeet * 0.3048; // Not used in display string but kept for calculation consistency
                        const lengthInLinks = lengthInFeet / 0.66;

                        measurements.push({
                            id: Date.now() + '-freehand',
                            type: 'freehand',
                            points: currentDrawing.points,
                            value: `${lengthInFeet.toFixed(2)} ft / ${lengthInLinks.toFixed(2)} links`
                        });
                        outputDisplay.innerText = 'Freehand drawing added. Total Length: ' + measurements[measurements.length - 1].value;
                    } else {
                        outputDisplay.innerText = 'Freehand drawing cancelled (too short).';
                    }
                }
                // For polygon, angle, circle: currentDrawing is only cleared when the measurement is complete (e.g., double-click for polygon, 3rd click for angle, 2nd for circle)
                if (mode !== 'polygon' && mode !== 'angle' && mode !== 'circle') { // Clear for line, rect, freehand, text, counter
                    currentDrawing = null;
                }
                renderMeasurementsList(); // Update list after new measurement
            }

            // Only revert to pan mode if not in polygon/angle/circle drawing (where clicks continue the drawing)
            if (mode !== 'polygon' && mode !== 'angle' && mode !== 'circle' || (currentDrawing && currentDrawing.closed)) {
                mode = 'pan'; // Reset to pan mode after an action is completed
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
            }
        }

        // Double click to finish polygon
        function handleDoubleClick(e) {
            e.preventDefault();
            if (mode === 'polygon' && currentDrawing && currentDrawing.points.length >= 3) {
                const polygon = {
                    id: Date.now() + '-poly',
                    type: 'polygon',
                    points: currentDrawing.points,
                    closed: true, // Mark as closed
                    value: calculatePolygonArea(currentDrawing.points)
                };
                measurements.push(polygon);
                outputDisplay.innerText = 'Polygon drawn. Area: ' + polygon.value;
                currentDrawing = null;
                renderMeasurementsList(); // Update list after new measurement
                mode = 'pan'; // Reset to pan mode
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
            }
            magnifierDiv.style.display = 'none'; // Deactivate magnifier on double click for polygon
        }


        function handleWheel(e) {
            e.preventDefault();
            const zoomAmount = e.deltaY < 0 ? 1.1 : 0.9;

            const rect = mainCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Calculate mouse position relative to current pan and zoom
            const canvasX = (mouseX - pan.x) / zoom;
            const canvasY = (mouseY - pan.y) / zoom;

            zoom *= zoomAmount;

            // Adjust pan to keep the mouse point fixed on the canvas
            pan.x = mouseX - canvasX * zoom;
            pan.y = mouseY - canvasY * zoom;
        }

        let lastTouchDist = null;
        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDist = Math.hypot(dx, dy);
                magnifierDiv.style.display = 'none'; // Deactivate magnifier during multi-touch pan/zoom
                currentDrawing = null; // Clear any partial drawing
                mode = 'pan'; // Always go to pan mode on multi-touch
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
            } else if (e.touches.length === 1) {
                handlePointerDown(e.touches[0]);
            }
        }

        function handleTouchMove(e) {
            // For magnifier on touch, we track the first touch point.
            if (e.touches.length === 1 && magnifierDiv.style.display === 'block') {
                lastPointerClientX = e.touches[0].clientX;
                lastPointerClientY = e.touches[0].clientY;
                // Position the magnifier DIV so its center is at the current pointer location
                magnifierDiv.style.left = `${e.touches[0].clientX - (MAGNIFIER_SIZE / 2)}px`;
                magnifierDiv.style.top = `${e.touches[0].clientY - (MAGNIFIER_SIZE / 2)}px`;
            }

            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy);

                if (lastTouchDist) {
                    const zoomAmount = newDist / lastTouchDist;
                    const rect = mainCanvas.getBoundingClientRect();
                    const touchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const touchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                    const canvasX = (touchX - rect.left - pan.x) / zoom;
                    const canvasY = (touchY - rect.y - pan.y) / zoom;

                    zoom *= zoomAmount;
                    pan.x = touchX - rect.left - canvasX * zoom;
                    pan.y = touchY - rect.y - canvasY * zoom;
                }
                lastTouchDist = newDist;
                e.preventDefault(); // Prevent scrolling/zooming by browser
            } else if (e.touches.length === 1) {
                handlePointerMove(e.touches[0]);
            }
        }

        function handleTouchEnd(e) {
            lastTouchDist = null;
            if (e.touches.length === 0) {
                handlePointerUp();
            }
        }

        // Image loading
        imageLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                img.onload = () => {
                    imgLoaded = true;
                    // Initial pan to center image
                    pan = {
                        x: (mainCanvas.clientWidth - img.width) / 2,
                        y: (mainCanvas.clientHeight - img.height) / 2,
                    };
                    zoom = 1; // Reset zoom
                    measurements = []; // Clear measurements on new image load
                    renderMeasurementsList();
                    
                    outputDisplay.innerText = `Image loaded. Scale: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} ft. Now start measuring.`;
                    mode = 'pan'; // Default mode is pan
                    updateModeButtons();
                    canvasContainer.classList.remove('drawing-mode'); // Ensure crosshair is off
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Event listeners for scale inputs
        dpiInput.addEventListener('input', () => {
            PIXELS_PER_INCH_CURRENT = parseFloat(dpiInput.value);
            if (FEET_PER_INCH_CURRENT > 0) {
                scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT;
                outputDisplay.innerText = `Scale updated: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} ft.`;
            } else {
                 outputDisplay.innerText = `Error: Feet/Inch cannot be zero.`;
            }
            redraw();
        });

        feetPerInchInput.addEventListener('input', () => {
            FEET_PER_INCH_CURRENT = parseFloat(feetPerInchInput.value);
            if (FEET_PER_INCH_CURRENT > 0) {
                scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT;
                outputDisplay.innerText = `Scale updated: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} ft.`;
            } else {
                 outputDisplay.innerText = `Error: Feet/Inch cannot be zero.`;
            }
            redraw();
        });

        // Export measurements as CSV
        exportCsvBtn.addEventListener('click', () => {
            if (measurements.length === 0) {
                outputDisplay.innerText = 'No measurements to export.';
                return;
            }

            let csvContent = "Type,Value,Text,Count,Radius(ft),Points\n";
            measurements.forEach(m => {
                const type = m.type;
                const value = m.value || '';
                const text = m.text || '';
                const count = m.count !== undefined ? m.count : '';
                const radius = m.radius !== undefined ? m.radius.toFixed(2) : '';
                const points = m.points.map(p => `(${p.x.toFixed(2)},${p.y.toFixed(2)})`).join(';');
                csvContent += `${type},"${value}","${text}","${count}","${radius}","${points}"\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'measurements.csv');
            link.click();
            outputDisplay.innerText = 'Measurements exported as CSV.';
        });

        // Button event listeners
        drawLineBtn.addEventListener('click', () => {
            mode = 'line';
            currentDrawing = null; // Clear any ongoing drawing of another type
            outputDisplay.innerText = 'Click and drag to draw a line.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode'); // Show crosshair
        });
        drawRectangleBtn.addEventListener('click', () => {
            mode = 'rectangle';
            currentDrawing = null; // Clear any ongoing drawing of another type
            outputDisplay.innerText = 'Click and drag to draw a rectangle.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode'); // Show crosshair
        });
        drawPolygonBtn.addEventListener('click', () => {
            mode = 'polygon';
            currentDrawing = { type: 'polygon', points: [], closed: false }; // Initialize for new polygon
            outputDisplay.innerText = 'Click to add points for a polygon. Double-click to finish.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode'); // Show crosshair
        });
        drawAngleBtn.addEventListener('click', () => {
            mode = 'angle';
            currentDrawing = null; // Clear any ongoing drawing
            outputDisplay.innerText = 'Click 1: First arm end. Click 2: Vertex. Click 3: Second arm end.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawCircleBtn.addEventListener('click', () => {
            mode = 'circle';
            currentDrawing = null; // Clear any ongoing drawing
            outputDisplay.innerText = 'Click 1: Circle center. Click 2: Radius point.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        addTextBtn.addEventListener('click', () => {
            mode = 'text';
            currentDrawing = null;
            outputDisplay.innerText = 'Click on canvas to add a text note.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        addCounterBtn.addEventListener('click', () => {
            mode = 'counter';
            currentDrawing = null;
            outputDisplay.innerText = 'Click on canvas to add a counter.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        freehandBtn.addEventListener('click', () => {
            mode = 'freehand';
            currentDrawing = null;
            outputDisplay.innerText = 'Click and drag to draw freehand.';
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });

        // Style option listeners
        lineWidthInput.addEventListener('input', redraw);
        fontSizeInput.addEventListener('input', redraw);


        undoLastBtn.addEventListener('click', () => {
            if (measurements.length > 0) {
                measurements.pop(); // Remove last measurement
                outputDisplay.innerText = 'Last measurement undone.';
                renderMeasurementsList(); // Update list
            } else {
                outputDisplay.innerText = 'No measurements to undo.';
            }
        });
        resetAllBtn.addEventListener('click', () => {
            measurements = [];
            zoom = 1;
            pan = { x: 0, y: 0 };
            imgLoaded = false; // Also reset image
            img.src = '';
            outputDisplay.innerText = 'Canvas reset. Load an image and start measuring.';
            mode = 'pan';
            currentDrawing = null; // Ensure no partial drawing remains
            counterValue = 1; // Reset counter
            updateModeButtons();
            renderMeasurementsList(); // Clear list
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
        });

        // Event listener for deleting individual measurements from the list
        measurementsListDiv.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.index) {
                const indexToRemove = parseInt(e.target.dataset.index);
                if (indexToRemove >= 0 && indexToRemove < measurements.length) {
                    measurements.splice(indexToRemove, 1); // Remove from array
                    outputDisplay.innerText = 'Measurement deleted.';
                    renderMeasurementsList(); // Re-render list
                }
            }
        });

        // Update button styles based on current mode
        function updateModeButtons() {
            const allDrawButtons = [
                drawLineBtn, drawRectangleBtn, drawPolygonBtn,
                drawAngleBtn, drawCircleBtn, addTextBtn, addCounterBtn, freehandBtn
            ];
            allDrawButtons.forEach(btn => {
                // Reset to default colors
                btn.classList.remove(
                    'bg-green-600', 'bg-purple-600', 'bg-indigo-600',
                    'bg-pink-600', 'bg-orange-600', 'bg-teal-600', 'bg-cyan-600', 'bg-gray-600'
                );
                btn.classList.add(
                    btn.id.includes('Line') ? 'bg-green-500' :
                    btn.id.includes('Rectangle') ? 'bg-purple-500' :
                    btn.id.includes('Polygon') ? 'bg-indigo-500' :
                    btn.id.includes('Angle') ? 'bg-pink-500' :
                    btn.id.includes('Circle') ? 'bg-orange-500' :
                    btn.id.includes('Text') ? 'bg-teal-500' :
                    btn.id.includes('Counter') ? 'bg-cyan-500' :
                    'bg-gray-500'
                );
            });

            // Highlight active mode button
            const activeColor = {
                'line': 'bg-green-600',
                'rectangle': 'bg-purple-600',
                'polygon': 'bg-indigo-600',
                'angle': 'bg-pink-600',
                'circle': 'bg-orange-600',
                'text': 'bg-teal-600',
                'counter': 'bg-cyan-600',
                'freehand': 'bg-gray-600'
            };
            if (mode !== 'pan') {
                const activeButton = document.getElementById(mode + 'Btn');
                if (activeButton) {
                    activeButton.classList.remove(activeColor[mode].replace('600', '500')); // Remove 500 version
                    activeButton.classList.add(activeColor[mode]); // Add 600 version
                } else if (mode === 'text' || mode === 'counter') { // For text/counter, use their specific button IDs
                    const specificButton = document.getElementById(`add${mode === 'text' ? 'Text' : 'Counter'}Btn`);
                    if (specificButton) {
                         specificButton.classList.remove(activeColor[mode].replace('600', '500'));
                         specificButton.classList.add(activeColor[mode]);
                    }
                }
            }
        }


        // Attach main canvas event listeners
        mainCanvas.addEventListener('pointerdown', handlePointerDown);
        mainCanvas.addEventListener('pointermove', handlePointerMove);
        mainCanvas.addEventListener('pointerup', handlePointerUp);
        mainCanvas.addEventListener('wheel', handleWheel, { passive: false }); // Prevent default scroll
        mainCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        mainCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        mainCanvas.addEventListener('touchend', handleTouchEnd);
        mainCanvas.addEventListener('dblclick', handleDoubleClick); // Double click for polygon finish

        // Handle window resize
        window.addEventListener('resize', () => {
            if (imgLoaded) {
                pan = {
                    x: (mainCanvas.clientWidth - img.width * zoom) / 2,
                    y: (mainCanvas.clientHeight - img.height * zoom) / 2,
                };
            }
            // Re-render list and redraw on resize
            renderMeasurementsList();
        });
        window.addEventListener('orientationchange', () => {
            if (imgLoaded) {
                pan = {
                    x: (mainCanvas.clientWidth - img.width * zoom) / 2,
                    y: (mainCanvas.clientHeight - img.height * zoom) / 2,
                };
            }
            // Re-render list and redraw on orientation change
            renderMeasurementsList();
        });

        // Initial render of measurement list on load
        renderMeasurementsList();

        // Start the animation loop
        requestAnimationFrame(redraw);
    </script>
</body>
</html>
