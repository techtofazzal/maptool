<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Measurement by Tofazzal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- PDF.js CDN - Updated to 2.16.105 as per user's old code -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent body scroll */
            background-color: #f8fafc; /* Overall light background */
        }
        #toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 6px; /* Reduced gap for smaller buttons */
            padding: 8px; /* Reduced padding for smaller buttons */
            background: linear-gradient(to right, #ffffff, #f0f4f8); /* Subtle gradient for toolbar */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* More prominent shadow for toolbar */
            z-index: 10;
            border-bottom-left-radius: 12px; /* Rounded bottom corners */
            border-bottom-right-radius: 12px;
        }
        #toolbar button,
        #toolbar input[type="file"] {
            padding: 6px 12px; /* Reduced padding for smaller buttons */
            font-size: 0.8rem; /* Smaller font */
            border-radius: 9999px; /* Full rounded corners */
            box-shadow: 0 3px 6px rgba(0,0,0,0.12); /* Softer, more diffused shadow */
            transition: all 0.3s ease-in-out;
            border: 1px solid rgba(0,0,0,0.08); /* Subtle border for definition */
            background-image: linear-gradient(to bottom, var(--tw-gradient-from), var(--tw-gradient-to)); /* For Tailwind colors with gradients */
        }
        /* Define common button styles using Tailwind placeholders for custom gradients */
        #toolbar button.bg-blue-500 { --tw-gradient-from: #3b82f6; --tw-gradient-to: #2563eb; } /* Blue-500 to Blue-600 */
        #toolbar button.bg-green-500 { --tw-gradient-from: #22c55e; --tw-gradient-to: #16a34a; } /* Green-500 to Green-600 */
        #toolbar button.bg-purple-500 { --tw-gradient-from: #a855f7; --tw-gradient-to: #9333ea; } /* Purple-500 to Purple-600 */
        #toolbar button.bg-indigo-500 { --tw-gradient-from: #6366f1; --tw-gradient-to: #4f46e5; } /* Indigo-500 to Indigo-600 */
        #toolbar button.bg-pink-500 { --tw-gradient-from: #ec4899; --tw-gradient-to: #db2777; } /* Pink-500 to Pink-600 */
        #toolbar button.bg-orange-500 { --tw-gradient-from: #f97316; --tw-gradient-to: #ea580c; } /* Orange-500 to Orange-600 */
        #toolbar button.bg-teal-500 { --tw-gradient-from: #14b8a6; --tw-gradient-to: #0d9488; } /* Teal-500 to Teal-600 */
        #toolbar button.bg-cyan-500 { --tw-gradient-from: #06b6d4; --tw-gradient-to: #0891b2; } /* Cyan-500 to Cyan-600 */
        #toolbar button.bg-gray-500 { --tw-gradient-from: #6b7280; --tw-gradient-to: #4b5563; } /* Gray-500 to Gray-600 */
        #toolbar button.bg-gray-600 { --tw-gradient-from: #4b5563; --tw-gradient-to: #374151; } /* Gray-600 to Gray-700 for export */
        #toolbar button.bg-yellow-500 { --tw-gradient-from: #f59e0b; --tw-gradient-to: #d97706; } /* Yellow-500 to Yellow-600 */
        #toolbar button.bg-red-500 { --tw-gradient-from: #ef4444; --tw-gradient-to: #dc2626; } /* Red-500 to Red-600 */


        #toolbar button:hover {
            transform: translateY(-2px); /* More noticeable lift on hover */
            box-shadow: 0 6px 12px rgba(0,0,0,0.2); /* Stronger shadow on hover */
            filter: brightness(1.1); /* Slightly brighter on hover */
        }
        #toolbar label input[type="number"],
        #toolbar label input[type="range"] {
            padding: 5px 8px; /* Further reduced padding for inputs */
            font-size: 0.8rem; /* Smaller font for inputs */
            border-radius: 8px; /* Rounded corners for inputs */
            background-color: #e2e8f0; /* Tailwind gray-200 */
            border: 1px solid #94a3b8; /* Darker border for inputs */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.08); /* More defined inset shadow */
        }
        #main-content {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #canvas-container {
            position: relative;
            flex-grow: 1;
            background: #e2e8f0; /* Tailwind gray-200 */
            overflow: hidden;
            touch-action: none; /* Disable default touch actions for custom handling */
            cursor: default; /* Default cursor for pan mode */
            transition: all 0.2s ease-in-out;
        }
        #canvas-container.drawing-mode {
            cursor: crosshair; /* Crosshair cursor for drawing modes */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #f8fafc; /* Tailwind gray-50 */
            touch-action: none;
        }
        .magnifier {
            position: absolute;
            top: 10px; /* Fixed position from top */
            left: 10px; /* Fixed position from left */
            width: 200px; /* Increased size */
            height: 200px; /* Increased size */
            border: 2px solid #3b82f6; /* Blue-500 */
            border-radius: 8px; /* Rounded corners */
            overflow: hidden;
            pointer-events: none; /* Allow events to pass through */
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); /* Soft shadow */
            background-color: white; /* Fallback for transparency */
            display: none; /* Hidden by default */
        }
        #measurements-sidebar {
            width: 300px; /* Default width */
            flex-shrink: 0;
            background: #f1f5f9; /* Tailwind gray-100 */
            box-shadow: -2px 0 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease-in-out; /* Smooth transition for width */
            overflow: hidden; /* Hide overflow content during collapse */
        }
        #measurements-sidebar.collapsed {
            width: 50px; /* Collapsed width */
        }
        #measurements-sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: linear-gradient(to right, #e2e8f0, #cbd5e1); /* Subtle gradient for header */
            border-bottom: 1px solid #d1d5db;
        }
        #measurements-sidebar-header h3 {
            transition: opacity 0.3s ease-in-out, width 0.3s ease-in-out, padding 0.3s ease-in-out, margin 0.3s ease-in-out;
        }
        #measurements-sidebar.collapsed #measurements-sidebar-header h3 {
            opacity: 0;
            width: 0; /* Make it take no horizontal space */
            overflow: hidden; /* Hide content that might overflow during transition */
            padding: 0; /* Remove padding when collapsed */
            margin: 0; /* Remove margin when collapsed */
        }
        #measurements-sidebar-header button {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            color: #4b5563;
            transition: transform 0.3s ease-in-out;
            padding: 5px;
            border-radius: 50%; /* Make button circular */
        }
        #measurements-sidebar-header button:hover {
            background-color: #d1d5db;
        }
        #measurements-sidebar-header button.rotated {
            transform: rotate(180deg); /* Rotate arrow when collapsed */
        }
        #measurements-sidebar-content {
            flex-grow: 1;
            padding: 10px;
            overflow-y: auto;
            gap: 8px; /* Increased gap in sidebar */
            display: flex; /* Flexbox for measurements list */
            flex-direction: column;
            transition: opacity 0.3s ease-in-out;
        }
        #measurements-sidebar.collapsed #measurements-sidebar-content {
            opacity: 0;
            pointer-events: none; /* Disable interactions when collapsed */
        }

        .measurement-item {
            background: white;
            padding: 10px; /* Increased padding */
            border-radius: 8px; /* More rounded corners */
            box-shadow: 0 2px 4px rgba(0,0,0,0.08); /* Softer item shadow */
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem; /* Slightly larger text */
        }
        .measurement-item button {
            background: #ef4444; /* Red-500 */
            color: white;
            border: none;
            border-radius: 6px; /* More rounded delete button */
            padding: 6px 12px; /* Nicer padding */
            cursor: pointer;
            font-size: 0.75rem;
            transition: background-color 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08); /* Small shadow on delete button */
        }
        .measurement-item button.edit-btn {
            background: #22c55e; /* Green-500 for edit button */
            margin-left: 5px; /* Add some space between delete and edit */
        }
        .measurement-item button:hover {
            background: #dc2626; /* Red-600 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* Slightly larger shadow on hover */
        }
        .measurement-item button.edit-btn:hover {
            background: #16a34a; /* Green-600 for edit button hover */
        }
        #output {
            padding: 12px; /* Increased padding */
            background: linear-gradient(to right, #ffffff, #f0f4f8); /* Subtle gradient */
            text-align: center;
            box-shadow: 0 -4px 8px rgba(0,0,0,0.15); /* More prominent shadow */
            z-index: 10;
            font-weight: 500; /* Medium font weight */
            color: #334155; /* Slate-700 */
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }

        /* Toolbar Collapse Specific Styles */
        #collapsible-toolbar-content {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 500px; /* Arbitrary large height to allow content to show */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 1;
            width: 100%; /* Ensure it takes full width when visible */
        }
        #collapsible-toolbar-content.collapsed {
            max-height: 0;
            opacity: 0;
            pointer-events: none; /* Disable interactions when collapsed */
            margin-top: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        #toolbar-toggle-button {
            background-color: #f0f4f8; /* Light background for toggle button */
            color: #4b5563;
            border: 1px solid #d1d5db;
            padding: 6px 12px;
            border-radius: 9999px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease-in-out;
        }
        #toolbar-toggle-button:hover {
            background-color: #e2e8f0;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        #toolbar-toggle-button .fas {
            transition: transform 0.3s ease-in-out;
        }
        #toolbar-toggle-button.rotated .fas {
            transform: rotate(180deg);
        }

    </style>
</head>
<body>
    <!-- Toolbar -->
    <div id="toolbar">
        <div class="flex items-center space-x-2 flex-wrap gap-2">
            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
                Load Image: <!-- ছবি লোড করুন -->
                <input
                    type="file"
                    id="imageLoader"
                    accept="image/*, application/pdf"
                    class="block w-full text-sm text-gray-500 file:mr-4 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"
                />
            </label>

            <!-- Scale Inputs -->
            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
                DPI:
                <input type="number" id="dpiInput" value="400" min="1" class="w-16 px-2 py-1 rounded-full text-sm bg-gray-200" />
            </label>
            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
                Feet/Inch:
                <input type="number" id="feetPerInchInput" value="330" min="0.1" step="0.1" class="w-16 px-2 py-1 rounded-full text-sm bg-gray-200" />
            </label>

            <button
                id="calibrateScaleBtn"
                class="bg-blue-500 text-white hover:bg-blue-600 transition-colors duration-200"
            >
                Calibrate <!-- ক্যালিব্রেট করুন -->
            </button>

            <button
                id="confirmCalibrationBtn"
                class="bg-green-500 text-white hover:bg-green-600 transition-colors duration-200"
                style="display: none;"
            >
                Confirm <!-- নিশ্চিত করুন -->
            </button>
        </div>

        <div class="flex items-center space-x-2 flex-wrap gap-2">
            <button
                id="undoBtn"
                class="bg-yellow-500 text-white hover:bg-yellow-600 transition-colors duration-200"
                disabled
            >
                Undo <!-- পূর্বাবস্থায় ফিরিয়ে আনুন -->
            </button>
            <button
                id="redoBtn"
                class="bg-yellow-500 text-white hover:bg-yellow-600 transition-colors duration-200"
                disabled
            >
                Redo <!-- পুনরায় করুন -->
            </button>
            <button
                id="resetAllBtn"
                class="bg-red-500 text-white hover:bg-red-600 transition-colors duration-200"
            >
                Reset <!-- রিসেট করুন -->
            </button>
            <button
                id="exportCsvBtn"
                class="bg-gray-600 text-white hover:bg-gray-700 transition-colors duration-200"
            >
                Export <!-- এক্সপোর্ট করুন -->
            </button>
            <span class="px-3 py-1 rounded-full text-sm font-semibold bg-gray-200 text-gray-700 border border-gray-300 shadow-sm">
                Unit: ft (Feet) <!-- একক: ফিট -->
            </span>
        </div>

        <!-- Toolbar Toggle Button -->
        <button id="toolbar-toggle-button" class="ml-auto">
            <span class="mr-2">More Tools</span> <i class="fas fa-chevron-down"></i> <!-- আরও টুলস -->
        </button>

        <!-- Collapsible Toolbar Content -->
        <div id="collapsible-toolbar-content" class="collapsed">
            <button
                id="drawLineBtn"
                class="bg-green-500 text-white hover:bg-green-600 transition-colors duration-200"
            >
                Line <!-- লাইন -->
            </button>

            <button
                id="drawRectangleBtn"
                class="bg-purple-500 text-white hover:bg-purple-600 transition-colors duration-200"
            >
                Rectangle <!-- আয়তক্ষেত্র -->
            </button>

            <button
                id="drawPolygonBtn"
                class="bg-indigo-500 text-white hover:bg-indigo-600 transition-colors duration-200"
            >
                Polygon <!-- বহুভুজ -->
            </button>
            
            <button
                id="drawAngleBtn"
                class="bg-pink-500 text-white hover:bg-pink-600 transition-colors duration-200"
            >
                Angle <!-- কোণ -->
            </button>

            <button
                id="drawCircleBtn"
                class="bg-orange-500 text-white hover:bg-orange-600 transition-colors duration-200"
            >
                Circle <!-- বৃত্ত -->
            </button>

            <button
                id="addTextBtn"
                class="bg-teal-500 text-white hover:bg-teal-600 transition-colors duration-200"
            >
                Text <!-- টেক্সট -->
            </button>

            <button
                id="addCounterBtn"
                class="bg-cyan-500 text-white hover:bg-cyan-600 transition-colors duration-200"
            >
                Counter <!-- কাউন্টার -->
            </button>

            <button
                id="freehandBtn"
                class="bg-gray-500 text-white hover:bg-gray-600 transition-colors duration-200"
            >
                Freehand <!-- ফ্রিহ্যান্ড -->
            </button>

            <!-- Style Options -->
            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
                Line Width: <!-- লাইনের প্রস্থ -->
                <input type="range" id="lineWidthInput" min="1" max="10" value="2" class="w-20" />
            </label>
            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700">
                Font Size: <!-- ফন্টের আকার -->
                <input type="range" id="fontSizeInput" min="10" max="30" value="14" class="w-20" />
            </label>
        </div>
    </div>

    <!-- Main Content Area (Canvas + Sidebar) -->
    <div id="main-content">
        <!-- Canvas Container -->
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <!-- Magnifier Canvas -->
            <div id="magnifier" class="magnifier">
                <canvas id="magnifierCanvas"></canvas>
            </div>
        </div>

        <!-- Measurements Sidebar -->
        <!-- Removed 'collapsed' class so it starts expanded -->
        <div id="measurements-sidebar">
            <div id="measurements-sidebar-header">
                <h3 class="text-lg font-bold">Measurements</h3>
                <!-- Changed initial icon to fa-chevron-left (collapse) when expanded -->
                <button id="sidebar-toggle-button">
                    <i class="fas fa-chevron-left"></i>
                </button>
            </div>
            <div id="measurements-sidebar-content">
                <div id="measurementsList" class="flex flex-col gap-2">
                    <!-- Measurements will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Output / Message Bar -->
    <div id="output">
        Load an image or PDF and start measuring. <!-- একটি ছবি বা পিডিএফ লোড করুন এবং পরিমাপ শুরু করুন। -->
    </div>

    <script>
        // Set up PDF.js worker source
        // This is crucial for PDF.js to function correctly in a web environment.
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js'; // Using user's requested version

        // Get references to HTML elements
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        const imageLoader = document.getElementById('imageLoader');
        const drawLineBtn = document.getElementById('drawLineBtn');
        const drawRectangleBtn = document.getElementById('drawRectangleBtn');
        const drawPolygonBtn = document.getElementById('drawPolygonBtn');
        const drawAngleBtn = document.getElementById('drawAngleBtn');
        const drawCircleBtn = document.getElementById('drawCircleBtn');
        const addTextBtn = document.getElementById('addTextBtn');
        const addCounterBtn = document.getElementById('addCounterBtn');
        const freehandBtn = document.getElementById('freehandBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const undoBtn = document.getElementById('undoBtn'); // Renamed from undoLastBtn
        const redoBtn = document.getElementById('redoBtn'); // New redo button
        const resetAllBtn = document.getElementById('resetAllBtn');
        const outputDisplay = document.getElementById('output');
        const magnifierDiv = document.getElementById('magnifier');
        const magnifierCanvas = document.getElementById('magnifierCanvas');
        const magnifyCtx = magnifierCanvas.getContext('2d');
        const measurementsListDiv = document.getElementById('measurementsList');
        const canvasContainer = document.getElementById('canvas-container');
        const calibrateScaleBtn = document.getElementById('calibrateScaleBtn'); 
        const confirmCalibrationBtn = document.getElementById('confirmCalibrationBtn');

        const dpiInput = document.getElementById('dpiInput');
        const feetPerInchInput = document.getElementById('feetPerInchInput');
        const lineWidthInput = document.getElementById('lineWidthInput');
        const fontSizeInput = document.getElementById('fontSizeInput');

        // Sidebar and Toolbar Collapse elements
        const sidebar = document.getElementById('measurements-sidebar');
        const sidebarToggleButton = document.getElementById('sidebar-toggle-button');
        const toolbarToggleButton = document.getElementById('toolbar-toggle-button');
        const collapsibleToolbarContent = document.getElementById('collapsible-toolbar-content');


        // Global state variables
        let img = new Image(); // Used for both images and a representation of the rendered PDF
        let imgLoaded = false; // True if an image or PDF is loaded and ready
        let zoom = 1; // Current zoom level of the canvas
        let pan = { x: 0, y: 0 }; // Current pan offset of the canvas
        let isDragging = false; // True if mouse/touch is currently dragging
        // startPoint will now consistently store the canvas coordinates of the point that was clicked for dragging.
        let startPoint = { x: 0, y: 0 }; 
        let currentDrawing = null; // Stores temporary points for the currently active drawing operation
        // selectedPoint now stores original coordinates of the point being dragged for more precise movement.
        let selectedPoint = null; // Stores info about a point being dragged/edited { measurementIndex, pointIndex, type, originalX, originalY, cornerType (for rectangle) }
        let mode = 'pan'; // Current interaction mode: 'pan', 'calibrate', 'line', etc.
        let measurements = []; // Array to store all completed measurements
        let counterValue = 1; // Counter for the 'addCounter' tool
        let snappedToPoint = null; // Stores the {x, y} of the point currently being snapped to, for visual feedback

        // History for Undo/Redo
        let measurementHistory = [];
        let historyPointer = -1;

        const unit = 'ft'; // Measurement unit (always feet in this application)
        
        // Scale factors: dynamically updated from UI inputs or calibration
        let PIXELS_PER_INCH_CURRENT = parseFloat(dpiInput.value); // Pixels per inch (DPI)
        let FEET_PER_INCH_CURRENT = parseFloat(feetPerInchInput.value); // Feet per physical inch on the original document
        // Calculated pixels per foot: this is the main conversion factor from canvas pixels to real-world feet
        let scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT; 

        const HIT_RADIUS_BASE = 10; // Base radius (in CSS pixels) for detecting if a point is clicked
        const SNAP_RADIUS = 3; // Snap radius as requested by the user
        const MAGNIFIER_SIZE = 200; // Dimensions of the magnifier display (in CSS pixels)
        const MAGNIFIER_ZOOM = 3; // Zoom level inside the magnifier


        // Get device pixel ratio for high-DPI screens (e.g., Retina displays)
        // This ensures crisp rendering on high-resolution screens by scaling the canvas drawing buffer.
        const dpr = window.devicePixelRatio || 1;

        // Set magnifier canvas size, adjusting for device pixel ratio for clarity
        magnifierCanvas.width = MAGNIFIER_SIZE * dpr;
        magnifierCanvas.height = MAGNIFIER_SIZE * dpr;
        magnifyCtx.scale(dpr, dpr); // Scale the magnifier's drawing context by DPR

        /**
         * Helper: Converts screen coordinates (from a mouse/touch event) to canvas coordinates.
         * Accounts for the canvas's position on the screen, current pan, and zoom level.
         * @param {number} clientX - The clientX coordinate from a pointer event.
         * @param {number} clientY - The clientY coordinate from a pointer event.
         * @returns {{x: number, y: number}} The corresponding canvas coordinates.
         */
        function getCanvasCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            const x = (clientX - rect.left - pan.x) / zoom;
            const y = (clientY - rect.top - pan.y) / zoom;
            return { x, y };
        }

        /**
         * Helper: Converts canvas coordinates to screen coordinates.
         * Used to draw points or text at their correct screen positions after pan/zoom.
         * @param {number} x - The canvas X coordinate.
         * @param {number} y - The Canvas Y coordinate.
         * @returns {{x: number, y: number}} The corresponding screen coordinates (relative to canvas top-left).
         */
        function getScreenCoords(x, y) {
            const screenX = x * zoom + pan.x;
            const screenY = y * zoom + pan.y;
            return { x: screenX, y: screenY };
        }

        /**
         * Helper: Gets canvas coordinates, potentially snapping to existing nearby points.
         * This creates a "magnetic" effect when drawing near existing measurement points.
         * @param {number} clientX - The clientX coordinate from a pointer event.
         * @param {number} clientY - The clientY coordinate from a pointer event.
         * @returns {{x: number, y: number}} The snapped or original canvas coordinates.
         */
        function getSnappedCanvasCoords(clientX, clientY) {
            let { x, y } = getCanvasCoords(clientX, clientY);
            snappedToPoint = null; // Reset snapped point for each check

            const currentScreenX = clientX;
            const currentScreenY = clientY;

            // Iterate through all existing measurement points AND midpoints for snapping
            const allSnappablePoints = [];
            
            measurements.forEach(m => {
                if (m.type !== 'freehand') { // Freehand not included for snapping points
                    m.points.forEach(p => allSnappablePoints.push(p));
                }

                // Add midpoints of segments for snapping (Lines, Rectangles, Polygons, Angles)
                if (m.type === 'line' || m.type === 'calibration') {
                    const midX = (m.points[0].x + m.points[1].x) / 2;
                    const midY = (m.points[0].y + m.points[1].y) / 2;
                    allSnappablePoints.push({ x: midX, y: midY });
                } else if (m.type === 'rectangle') {
                    const [p1, p2] = m.points;
                    // For snapping, consider the four actual visual corners
                    const corners = [
                        {x: p1.x, y:p1.y}, 
                        {x:p2.x, y:p1.y}, 
                        {x:p2.x, y:p2.y}, 
                        {x:p1.x, y:p2.y}
                    ];
                    corners.forEach(c => allSnappablePoints.push(c));
                    // Also add midpoints of rectangle sides for snapping
                    const sidesMidpoints = [
                        {x: (p1.x + p2.x) / 2, y: p1.y}, // Top Mid
                        {x: p2.x, y: (p1.y + p2.y) / 2}, // Right Mid
                        {x: (p1.x + p2.x) / 2, y: p2.y}, // Bottom Mid
                        {x: p1.x, y: (p1.y + p2.y) / 2}  // Left Mid
                    ];
                    sidesMidpoints.forEach(sm => allSnappablePoints.push(sm));
                } else if (m.type === 'polygon' && m.closed) { // Snap to midpoints of polygon segments once closed
                    for(let i=0; i<m.points.length; i++) {
                        const pA = m.points[i];
                        const pB = m.points[(i+1) % m.points.length];
                        const midX = (pA.x + pB.x) / 2;
                        const midY = (pA.y + pB.y) / 2;
                        allSnappablePoints.push({x: midX, y: midY});
                    }
                } else if (m.type === 'angle' && m.points.length === 3) { // Snap to midpoints of angle arms
                    const [p1, p2, p3] = m.points;
                    const mid1X = (p1.x + p2.x) / 2;
                    const mid1Y = (p1.y + p2.y) / 2;
                    const mid2X = (p2.x + p3.x) / 2;
                    const mid2Y = (p2.y + p3.y) / 2;
                    allSnappablePoints.push({x: mid1X, y: mid1Y}, {x: mid2X, y: mid2Y});
                } else if (m.type === 'circle' && m.points.length === 2) { // Snap to circle center and a point on circumference
                    allSnappablePoints.push(m.points[0]); // center
                    const radius = Math.hypot(m.points[1].x - m.points[0].x, m.points[1].y - m.points[0].y);
                    // Add points on circumference (e.g., at 0, 90, 180, 270 degrees)
                    allSnappablePoints.push(
                        { x: m.points[0].x + radius, y: m.points[0].y },
                        { x: m.points[0].x - radius, y: m.points[0].y },
                        { x: m.points[0].x, y: m.points[0].y + radius },
                        { x: m.points[0].x, y: m.points[0].y - radius }
                    );
                }
            });

            // Add points from the current drawing (e.g., polygon points, calibration points)
            if (currentDrawing && currentDrawing.points) {
                if (currentDrawing.type === 'calibrate' && currentDrawing.points.length >= 1) {
                    allSnappablePoints.push(...currentDrawing.points);
                } else if (currentDrawing.type === 'polygon' && currentDrawing.points.length >= 1) {
                    allSnappablePoints.push(...currentDrawing.points);
                } else if (currentDrawing.type === 'angle' && currentDrawing.points.length >= 1) {
                    allSnappablePoints.push(...currentDrawing.points);
                } else if (currentDrawing.type === 'circle' && currentDrawing.points.length >= 1) {
                    allSnappablePoints.push(...currentDrawing.points);
                }
            }


            for (const p of allSnappablePoints) {
                const screenP = getScreenCoords(p.x, p.y);
                // Calculate distance in CSS pixels between current pointer and existing point
                const dist = Math.hypot(currentScreenX - (mainCanvas.getBoundingClientRect().left + screenP.x), currentScreenY - (mainCanvas.getBoundingClientRect().top + screenP.y));
                
                // If within SNAP_RADIUS, snap to this point
                if (dist < SNAP_RADIUS) {
                    x = p.x;
                    y = p.y;
                    snappedToPoint = p; // Store the snapped point for visual feedback
                    break; // Found a point to snap to, no need to check others for this measurement
                }
            }
            return { x, y };
        }


        /**
         * Helper: Draws a circle to represent a point on the canvas.
         * The radius scales with line width but not zoom, ensuring consistent visual size.
         * @param {CanvasRenderingContext2D} context - The canvas rendering context.
         * @param {number} x - The X coordinate of the point on the canvas.
         * @param {number} y - The Y coordinate of the point on the canvas.
         * @param {number} currentZoom - The current zoom level (unused for scaling here, but kept for consistency).
         */
        function drawPoint(context, x, y, currentZoom) {
            context.beginPath();
            // Point radius depends on lineWidthInput.value for visual consistency.
            // It's already scaled by the context, so no need to divide by zoom here.
            const pointRadius = parseFloat(lineWidthInput.value) * 1.5; 
            context.arc(x, y, pointRadius, 0, Math.PI * 2);
            context.fill();
        }

        /**
         * Helper: Draws an arrowhead at the end of a line. (Currently unused in the UI but available).
         * @param {CanvasRenderingContext2D} context - The canvas rendering context.
         * @param {{x: number, y: number}} p1 - Start point of the line.
         * @param {{x: number, y: number}} p2 - End point of the line (where arrowhead is drawn).
         * @param {number} size - Size of the arrowhead.
         */
        function drawArrowhead(context, p1, p2, size) {
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            context.save();
            context.translate(p2.x, p2.y);
            context.rotate(angle);
            context.beginPath();
            context.moveTo(-size, -size / 2);
            context.lineTo(0, 0);
            context.lineTo(-size, size / 2);
            context.lineTo(-size, size / 2); // Duplicate, could be a copy-paste error in original
            context.fill();
            context.restore();
        }

        /**
         * Helper: Sets the line style (e.g., solid, dashed) for the given context.
         * Currently always sets a solid line.
         * @param {CanvasRenderingContext2D} context - The canvas rendering context.
         */
        function setLineStyle(context) {
            context.setLineDash([]); // Solid line
        }

        /**
         * Calculates the real-world length of a line segment.
         * @param {{x: number, y: number}} p1 - Start point in canvas coordinates.
         * @param {{x: number, y: number}} p2 - End point in canvas coordinates.
         * @returns {string} Formatted length string in feet and links.
         */
        function calculateLineLength(p1, p2) {
            const lengthInPixels = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const lengthInFeet = lengthInPixels / scaleFactorPixelsPerUnit;
            const lengthInLinks = lengthInFeet / 0.66; // 1 link = 0.66 feet
            return `${lengthInFeet.toFixed(2)} ft / ${lengthInLinks.toFixed(2)} links`;
        }

        /**
         * Calculates the real-world area of a rectangle.
         * @param {{x: number, y: number}} p1 - Top-left point in canvas coordinates.
         * @param {{x: number, y: number}} p2 - Bottom-right point in canvas coordinates.
         * @returns {{sqFt: number, shotok: number}} Object containing square feet and shotok.
         */
        function calculateRectangleArea(p1, p2) {
            const widthPixels = Math.abs(p2.x - p1.x);
            const heightPixels = Math.abs(p2.y - p1.y);
            const widthFeet = widthPixels / scaleFactorPixelsPerUnit;
            const heightFeet = heightPixels / scaleFactorPixelsPerUnit;
            const areaSqFt = widthFeet * heightFeet;
            const areaShotok = areaSqFt / 435.6; // 1 shotok = 435.6 sq ft
            return { sqFt: areaSqFt, shotok: areaShotok };
        }

        /**
         * Calculates the real-world area of a polygon using the Shoelace formula.
         * @param {Array<{x: number, y: number}>} points - Array of polygon vertices in canvas coordinates.
         * @returns {{sqFt: number, shotok: number} | {sqFt: null, shotok: null}} Object containing square feet and shotok, or null if less than 3 points.
         */
        function calculatePolygonArea(points) {
            if (points.length < 3) return { sqFt: null, shotok: null };
            let areaPixels = 0;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                areaPixels += (p1.x * p2.y - p2.x * p1.y);
            }
            areaPixels = Math.abs(areaPixels / 2); // Area in pixels²

            const areaSqFt = areaPixels / (scaleFactorPixelsPerUnit * scaleFactorPixelsPerUnit);
            const areaShotok = areaSqFt / 435.6; // 1 shotok = 435.6 sq ft
            return { sqFt: areaSqFt, shotok: areaShotok };
        }

        /**
         * Calculates the angle between three points (p1-p2-p3, where p2 is the vertex).
         * @param {{x: number, y: number}} p1 - First point.
         * @param {{x: number, y: number}} p2 - Vertex point.
         * @param {{x: number, y: number}} p3 - Third point.
         * @returns {string} Formatted angle string in degrees, or 'N/A' if points are coincident.
         */
        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            const magnitude1 = Math.hypot(v1.x, v1.y);
            const magnitude2 = Math.hypot(v2.x, v2.y);

            if (magnitude1 === 0 || magnitude2 === 0) return 'N/A';

            let angleRad = Math.acos(dotProduct / (magnitude1 * magnitude2));
            let angleDeg = angleRad * (180 / Math.PI);
            return `${angleDeg.toFixed(2)}°`;
        }

        /**
         * The main redraw function for the canvas.
         * This function is called repeatedly via requestAnimationFrame to keep the canvas updated.
         * It draws the loaded image/PDF, all existing measurements, and any temporary drawing in progress.
         */
        function redraw() {
            // Adjust canvas dimensions for high-DPI screens
            mainCanvas.width = mainCanvas.clientWidth * dpr;
            mainCanvas.height = mainCanvas.clientHeight * dpr;

            ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); // Clear the entire canvas

            ctx.save(); // Save the current state of the context
            ctx.scale(dpr, dpr); // Scale the context by device pixel ratio for sharp rendering
            ctx.translate(pan.x, pan.y); // Apply panning offset
            ctx.scale(zoom, zoom); // Apply zoom level

            // Get current line width and font size from UI inputs
            const currentLineWidth = parseFloat(lineWidthInput.value);
            const currentFontSize = parseFloat(fontSizeInput.value);

            // Draw the loaded image or PDF content
            if (imgLoaded) {
                // img.src contains the rendered image data (for both image and PDF after conversion)
                ctx.drawImage(img, 0, 0);
            }

            // Draw all existing measurements stored in the 'measurements' array
            measurements.forEach((m) => {
                ctx.strokeStyle = 'red'; // Line color for measurements
                ctx.lineWidth = currentLineWidth / zoom; // Adjust line width based on zoom
                ctx.fillStyle = 'blue'; // Text and point color
                ctx.font = `${currentFontSize / zoom}px sans-serif`; // Adjust font size based on zoom
                ctx.textAlign = 'center'; // Center text for measurements
                ctx.textBaseline = 'middle'; // Center text vertically
                setLineStyle(ctx); // Always solid line

                if (m.type === 'line' || m.type === 'calibration') {
                    const [p1, p2] = m.points;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p2.x, p2.y, zoom);
                    if (m.value) { // Display value for calibration line
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        ctx.fillText(m.value, midX, midY - (currentFontSize / zoom / 2 + 2));
                    }
                } else if (m.type === 'rectangle') {
                    const [p1, p2] = m.points; 
                    // Calculate corners based on p1 (top-left) and p2 (bottom-right)
                    const c1 = { x: p1.x, y: p1.y };
                    const c2 = { x: p2.x, y: p1.y };
                    const c3 = { x: p2.x, y: p2.y };
                    const c4 = { x: p1.x, y: p2.y };

                    ctx.beginPath();
                    ctx.moveTo(c1.x, c1.y);
                    ctx.lineTo(c2.x, c2.y);
                    ctx.lineTo(c3.x, c3.y);
                    ctx.lineTo(c4.x, c4.y);
                    ctx.closePath(); // Close the rectangle path
                    ctx.stroke(); // Draw the rectangle outline
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; /* Transparent light gray fill */
                    ctx.fill(); // Fill the rectangle
                    ctx.fillStyle = 'blue'; /* Reset fillStyle for text/points */

                    // Draw segment measurements (length of each side)
                    const segments = [
                        { p1: c1, p2: c2 }, { p1: c2, p2: c3 }, 
                        { p1: c3, p2: c4 }, { p1: c4, p2: c1 }  
                    ];
                    segments.forEach(seg => {
                        const midX = (seg.p1.x + seg.p2.x) / 2;
                        const midY = (seg.p1.y + seg.p2.y) / 2; 
                        const length = calculateLineLength(seg.p1, seg.p2);
                        // Only display feet length for segments
                        ctx.fillText(length.split(' / ')[0], midX, midY - (currentFontSize / zoom / 2 + 2)); 
                    });

                    // Draw points at each corner to indicate they are editable
                    drawPoint(ctx, c1.x, c1.y, zoom);
                    drawPoint(ctx, c2.x, c2.y, zoom);
                    drawPoint(ctx, c3.x, c3.y, zoom);
                    drawPoint(ctx, c4.x, c4.y, zoom);

                    if (m.areaSqFt !== undefined && m.areaShotok !== undefined) {
                        const centerX = c1.x + (p2.x - p1.x) / 2;
                        const centerY = c1.y + (p2.y - p1.y) / 2;
                        const textOffset = currentFontSize / zoom / 2 + 2; 
                        ctx.fillText(`${m.areaSqFt.toFixed(2)} sq ft`, centerX, centerY - textOffset);
                        ctx.fillText(`${m.areaShotok.toFixed(4)} shotok`, centerX, centerY + textOffset);
                    }
                } else if (m.type === 'polygon') {
                    if (m.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(m.points[0].x, m.points[0].y);
                        for (let i = 1; i < m.points.length; i++) {
                            ctx.lineTo(m.points[i].x, m.points[i].y);
                        }
                        if (m.points.length > 2 && m.closed) {
                            ctx.closePath(); // Close the polygon path if marked as closed
                            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; /* Transparent light gray fill */
                            ctx.fill(); // Fill the polygon
                            ctx.fillStyle = 'blue'; /* Reset fillStyle for text/points */
                        }
                        ctx.stroke(); // Draw the polygon outline

                        // Draw segment measurements for each side of the polygon
                        for (let i = 0; i < m.points.length; i++) {
                            const p1 = m.points[i];
                            const p2 = m.points[(i + 1) % m.points.length]; // Connect last to first if closed
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const length = calculateLineLength(p1, p2);
                            // Only display feet length for segments
                            ctx.fillText(length.split(' / ')[0], midX, midY - (currentFontSize / zoom / 2 + 2)); 
                        }

                        m.points.forEach(p => drawPoint(ctx, p.x, p.y, zoom)); // Draw points at each vertex
                        if (m.closed && m.areaSqFt !== undefined && m.areaShotok !== undefined) {
                            // Display area in the centroid of the polygon
                            let sumX = 0, sumY = 0;
                            m.points.forEach(p => { sumX += p.x; sumY += p.y; });
                            const centroidX = sumX / m.points.length;
                            const centroidY = sumY / m.points.length; 
                            const textOffset = currentFontSize / zoom / 2 + 2; 
                            ctx.fillText(`${m.areaSqFt.toFixed(2)} sq ft`, centroidX, centroidY - textOffset); 
                            ctx.fillText(`${m.areaShotok.toFixed(4)} shotok`, centroidX, centroidY + textOffset); 
                        }
                    }
                } else if (m.type === 'angle') {
                    const [p1, p2, p3] = m.points; // p2 is the vertex of the angle
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.stroke(); // Draw the two arms of the angle
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p2.x, p2.y, zoom);
                    drawPoint(ctx, p3.x, p3.y, zoom);

                    // Draw an arc to visually represent the angle
                    const angleRadius = 30 / zoom; // Size of the arc, adjusted for zoom
                    const startAngle = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                    const endAngle = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                    
                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, angleRadius, startAngle, endAngle);
                    ctx.stroke();

                    // Position text for angle value near the arc
                    const textAngle = (startAngle + endAngle) / 2;
                    const textX = p2.x + Math.cos(textAngle) * (angleRadius + 10 / zoom);
                    const textY = p2.y + Math.sin(textAngle) * (angleRadius + 10 / zoom);
                    ctx.fillText(m.value, textX, textY);

                    // Show arm lengths
                    const len1 = calculateLineLength(p1, p2);
                    const len2 = calculateLineLength(p2, p3);
                    ctx.fillText(len1.split(' / ')[0], (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 - (currentFontSize / zoom / 2 + 2));
                    ctx.fillText(len2.split(' / ')[0], (p2.x + p3.x) / 2, (p2.y + p3.y) / 2 - (currentFontSize / zoom / 2 + 2));
                } else if (m.type === 'circle') {
                    const [center, radiusPoint] = m.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2); // Draw the circle
                    ctx.stroke();
                    drawPoint(ctx, center.x, center.y, zoom); // Draw center point
                    drawPoint(ctx, radiusPoint.x, radiusPoint.y, zoom); // Draw radius point
                    if (m.value) {
                        ctx.fillText(m.value, center.x, center.y - radius - (currentFontSize / zoom / 2 + 2)); // Display value above circle
                    }
                    // Show radius length
                    const radiusLength = calculateLineLength(center, radiusPoint);
                    ctx.fillText("Radius: " + radiusLength.split(' / ')[0], (center.x + radiusPoint.x) / 2, (center.y + radiusPoint.y) / 2 - (currentFontSize / zoom / 2 + 2));
                } else if (m.type === 'text') {
                    ctx.fillStyle = 'blue'; // Text color
                    ctx.font = `${currentFontSize / zoom}px sans-serif`;
                    ctx.fillText(m.text, m.points[0].x, m.points[0].y); // Draw text at its point
                } else if (m.type === 'counter') {
                    ctx.fillStyle = 'blue'; // Counter color
                    ctx.font = `${currentFontSize / zoom}px sans-serif`;
                    ctx.fillText(m.count, m.points[0].x, m.points[0].y); // Draw counter number
                    drawPoint(ctx, m.points[0].x, m.points[0].y, zoom); // Draw point for counter
                } else if (m.type === 'freehand') {
                    if (m.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(m.points[0].x, m.points[0].y);
                        for (let i = 1; i < m.points.length; i++) {
                            ctx.lineTo(m.points[i].x, m.points[i].y);
                        }
                        ctx.stroke(); // Draw the freehand path
                    }
                    if (m.value) { // Display total length for freehand path
                        const firstPoint = m.points[0];
                        ctx.fillText(m.value, firstPoint.x + 5 / zoom, firstPoint.y - (currentFontSize / zoom / 2 + 2));
                    }
                }
            });

            // Ensure current drawing (temporary) is also drawn with a solid line style
            setLineStyle(ctx);

            // Draw current temporary drawing (e.g., line as it's being dragged, polygon segments)
            if (currentDrawing) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = currentLineWidth / zoom;
                ctx.fillStyle = 'blue';
                ctx.font = `${currentFontSize / zoom}px sans-serif`;
                ctx.textAlign = 'center'; // Center text for temporary measurements
                ctx.textBaseline = 'middle'; // Center text vertically

                if (mode === 'line' || mode === 'rectangle') { // Drag-to-draw tools
                    const [p1, p2] = currentDrawing.points;
                    if (mode === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    } else { // Rectangle
                        const width = p2.x - p1.x;
                        const height = p2.y - p1.y;
                        ctx.strokeRect(p1.x, p1.y, width, height);
                    }
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    drawPoint(ctx, p2.x, p2.y, zoom);
                } else if (mode === 'polygon') {
                    if (currentDrawing.points.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                        for (let i = 1; i < currentDrawing.points.length; i++) {
                            ctx.lineTo(currentDrawing.points[i].x, currentDrawing.points[i].y);
                        }
                        // Draw temporary line from last point to current mouse position (snapped)
                        const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                        currentDrawing.points.forEach(p => drawPoint(ctx, p.x, p.y, zoom));
                    }
                } else if (mode === 'angle' && currentDrawing.points.length > 0) {
                    drawPoint(ctx, currentDrawing.points[0].x, currentDrawing.points[0].y, zoom); // First point
                    if (currentDrawing.points.length === 1) { // Drawing first arm
                        const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.beginPath();
                        ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.stroke();
                    } else if (currentDrawing.points.length === 2) { // Drawing second arm
                        const [p1, p2] = currentDrawing.points; // p2 is vertex
                        const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y);
                        ctx.lineTo(mouseCanvasCoords.x, mouseCanvasCoords.y); // Draw a line to the snapped point
                        ctx.stroke();
                        drawPoint(ctx, p1.x, p1.y, zoom);
                        drawPoint(ctx, p2.x, p2.y, zoom);
                    }
                } else if (mode === 'circle' && currentDrawing.points.length > 0) {
                    const [center] = currentDrawing.points;
                    const mouseCanvasCoords = getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                    const radius = Math.hypot(mouseCanvasCoords.x - center.x, mouseCanvasCoords.y - center.y);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    drawPoint(ctx, center.x, center.y, zoom);
                } else if (mode === 'freehand' && currentDrawing.points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(currentDrawing.points[0].x, currentDrawing.points[0].y);
                    for (let i = 1; i < currentDrawing.points.length; i++) {
                        ctx.lineTo(currentDrawing.points[i].x, currentDrawing.points[i].y);
                    }
                    ctx.stroke();
                } else if (mode === 'calibrate' && currentDrawing.points.length >= 1) { // Live line for calibration (1 or 2 points)
                    const p1 = currentDrawing.points[0];
                    const p2 = currentDrawing.points.length === 2 ? currentDrawing.points[1] : getSnappedCanvasCoords(lastPointerClientX, lastPointerClientY);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    drawPoint(ctx, p1.x, p1.y, zoom);
                    if (currentDrawing.points.length === 1) { // Only draw second point if still selecting
                        drawPoint(ctx, p2.x, p2.y, zoom);
                    } else if (currentDrawing.points.length === 2) { // Draw both points if selected for editing
                        drawPoint(ctx, currentDrawing.points[1].x, currentDrawing.points[1].y, zoom);
                    }
                }
            }

            ctx.restore(); // Restore the context to its original state before this redraw

            // Draw magnifier content if active
            if (magnifierDiv.style.display === 'block') {
                magnifyCtx.clearRect(0, 0, MAGNIFIER_SIZE * dpr, MAGNIFIER_SIZE * dpr);

                // Get the current pointer position in CSS pixels relative to the main canvas's top-left
                const mainCanvasRect = mainCanvas.getBoundingClientRect();
                const pointerCssX_relativeToCanvas = lastPointerClientX - mainCanvasRect.left;
                const pointerCssY_relativeToCanvas = lastPointerClientY - mainCanvasRect.top;

                // The physical pixel coordinates on the mainCanvas's backing buffer where the cursor is
                const rawPixelX_under_cursor = pointerCssX_relativeToCanvas * dpr;
                const rawPixelY_under_cursor = pointerCssY_relativeToCanvas * dpr;

                // The size of the region to capture from the main canvas (in physical pixels).
                const sourceRegionPhysicalSize = (MAGNIFIER_SIZE / MAGNIFIER_ZOOM) * dpr;

                // Calculate the top-left corner of the source rectangle on the mainCanvas (physical pixels).
                // This rectangle will be centered around the rawPixelX_under_cursor/Y_under_cursor.
                const sourceX_physical = rawPixelX_under_cursor - (sourceRegionPhysicalSize / 2);
                const sourceY_physical = rawPixelY_under_cursor - (sourceRegionPhysicalSize / 2);
                
                // Draw a magnified portion of the main canvas onto the magnifier canvas
                magnifyCtx.drawImage(
                    mainCanvas, 
                    sourceX_physical, sourceY_physical, 
                    sourceRegionPhysicalSize, sourceRegionPhysicalSize, 
                    0, 0, MAGNIFIER_SIZE * dpr, MAGNIFIER_SIZE * dpr
                );

                // Draw a crosshair in the center of the magnifier for precise aiming
                magnifyCtx.strokeStyle = 'lime'; // Bright green crosshair
                magnifyCtx.lineWidth = 1 / dpr; // Scale line width by DPR on magnifier
                magnifyCtx.beginPath();
                magnifyCtx.moveTo(MAGNIFIER_SIZE / 2, 0);
                magnifyCtx.lineTo(MAGNIFIER_SIZE / 2, MAGNIFIER_SIZE);
                magnifyCtx.moveTo(0, MAGNIFIER_SIZE / 2);
                magnifyCtx.lineTo(MAGNIFIER_SIZE, MAGNIFIER_SIZE / 2);
                magnifyCtx.stroke();
            }

            requestAnimationFrame(redraw); // Request the next animation frame
        }

        /**
         * Renders the list of current measurements in the sidebar.
         * Clears the existing list and re-populates it with updated measurement data.
         */
        function renderMeasurementsList() {
            measurementsListDiv.innerHTML = ''; // Clear existing list items
            if (measurements.length === 0) {
                measurementsListDiv.innerHTML = '<p class="text-gray-600 text-sm">No measurements yet. Draw something!</p>'; 
                return;
            }
            // Create and append a div for each measurement
            measurements.forEach((m, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'measurement-item';
                let displayText = '';
                let buttonsHtml = `<button data-index="${index}" class="delete-btn">Delete</button>`; 

                // Determine display text based on measurement type
                if (m.type === 'line') {
                    displayText = `Line: ${m.value}`;
                } else if (m.type === 'rectangle') {
                    displayText = `Rectangle: ${m.value}`;
                } else if (m.type === 'polygon') {
                    displayText = `Polygon: ${m.value}`;
                } else if (m.type === 'angle') {
                    displayText = `Angle: ${m.value}`;
                } else if (m.type === 'circle') {
                    displayText = `Circle (R:${m.radius.toFixed(2)}ft): ${m.value}`;
                } else if (m.type === 'text') {
                    displayText = `Text: "${m.text}"`;
                    buttonsHtml += `<button data-index="${index}" class="edit-btn">Edit</button>`; 
                } else if (m.type === 'counter') {
                    displayText = `Counter: ${m.count}`;
                } else if (m.type === 'freehand') {
                    displayText = `Freehand Drawing (Length: ${m.value})`;
                } else if (m.type === 'calibration') {
                    displayText = `Calibration: ${m.value}`;
                }
                // Add measurement text and buttons
                itemDiv.innerHTML = `
                    <span class="text-sm font-medium text-gray-800">${displayText}</span>
                    <div>${buttonsHtml}</div>
                `;
                measurementsListDiv.appendChild(itemDiv);
            });
        }

        /**
         * Saves the current state of 'measurements' into the history stack.
         * This is called after any action that changes the measurements, for Undo/Redo.
         */
        function saveState() {
            // If pointer is not at the end of history, clear future states
            if (historyPointer < measurementHistory.length - 1) {
                measurementHistory = measurementHistory.slice(0, historyPointer + 1);
            }
            // Deep copy measurements to avoid reference issues
            measurementHistory.push(JSON.parse(JSON.stringify(measurements)));
            historyPointer = measurementHistory.length - 1;
            updateUndoRedoButtons();
        }

        /**
         * Updates the disabled state of Undo and Redo buttons based on history pointer.
         */
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyPointer <= 0;
            redoBtn.disabled = historyPointer >= measurementHistory.length - 1;
        }

        /**
         * Loads a specific state from history.
         * @param {number} index - The index in the history to load.
         */
        function loadState(index) {
            if (index >= 0 && index < measurementHistory.length) {
                measurements = JSON.parse(JSON.stringify(measurementHistory[index]));
                historyPointer = index;
                renderMeasurementsList();
                redraw();
                updateUndoRedoButtons();
            }
        }


        // Variables to track last pointer position for magnifier and temporary drawing feedback
        let lastPointerClientX = 0;
        let lastPointerClientY = 0;

        // --- Event Handlers for Canvas Interaction ---

        /**
         * Handles pointer down (mouse click or touch start) events on the main canvas.
         * Initiates panning, drawing, or point selection based on the current mode.
         * @param {PointerEvent} e - The pointerdown event object.
         */
        function handlePointerDown(e) {
            if (e.button === 2) return; // Ignore right-click

            // Get canvas coordinates, potentially snapping to existing points if not in pan mode or if editing a point
            const { x, y } = (mode !== 'pan' || selectedPoint) ? getSnappedCanvasCoords(e.clientX, e.clientY) : getCanvasCoords(e.clientX, e.clientY);
            
            // Store starting point for pan drag calculations (screen coords)
            startPoint = { x: e.clientX, y: e.clientY }; 
            isDragging = true;
            
            // Update last pointer position for magnifier
            lastPointerClientX = e.clientX;
            lastPointerClientY = e.clientY;

            // Reset snappedToPoint visual cue at the start of a drag/click
            snappedToPoint = null;

            if (mode === 'pan') {
                magnifierDiv.style.display = 'none'; // Hide magnifier in pan mode
            } else if (mode === 'calibrate') {
                if (!currentDrawing) { // First click for calibration
                    currentDrawing = { type: 'calibrate', points: [{ x, y }] };
                    outputDisplay.innerText = 'First calibration point set. Now move your mouse to the second point and click.'; 
                    magnifierDiv.style.display = 'block';
                } else if (currentDrawing.type === 'calibrate' && currentDrawing.points.length === 1) { // Second click for calibration
                    currentDrawing.points.push({ x, y }); // Add the second point
                    outputDisplay.innerText = 'Second calibration point set. Adjust line if needed, then click "Confirm".'; 
                    confirmCalibrationBtn.style.display = 'inline-block'; // Show confirm button
                    magnifierDiv.style.display = 'none'; // Hide magnifier after second click
                    // Now, set selectedPoint to allow dragging of the newly added point
                    selectedPoint = { measurementIndex: -1, pointIndex: 1, type: 'calibrate', originalX: x, originalY: y }; // -1 indicates currentDrawing
                }
            }
            else if (mode === 'line') {
                currentDrawing = { type: 'line', points: [{ x, y }, { x, y }] };
                outputDisplay.innerText = 'Click and drag to draw a line.'; 
                magnifierDiv.style.display = 'block';
            } else if (mode === 'rectangle') {
                currentDrawing = { type: 'rectangle', points: [{ x, y }, { x, y }] };
                outputDisplay.innerText = 'Click and drag to draw a rectangle.'; 
                magnifierDiv.style.display = 'block';
            } else if (mode === 'polygon') {
                if (!currentDrawing || currentDrawing.points.length === 0) { // Starting new polygon
                    currentDrawing = { type: 'polygon', points: [{ x, y }], closed: false };
                    outputDisplay.innerText = 'Click to add points for polygon. Double-click to finish.'; 
                } else { // Adding point to existing polygon
                    currentDrawing.points.push({ x, y });
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'angle') {
                if (!currentDrawing) {
                    currentDrawing = { type: 'angle', points: [{ x, y }] }; // First point (arm 1 end)
                    outputDisplay.innerText = '1: End of first arm. 2: Vertex. 3: End of second arm.'; 
                } else if (currentDrawing.points.length === 1) {
                    currentDrawing.points.push({ x, y }); // Second point (vertex)
                } else if (currentDrawing.points.length === 2) {
                    currentDrawing.points.push({ x, y }); // Third point (arm 2 end)
                    const [p1, p2, p3] = currentDrawing.points;
                    measurements.push({
                        id: Date.now() + '-angle',
                        type: 'angle',
                        points: currentDrawing.points,
                        value: calculateAngle(p1, p2, p3)
                    });
                    outputDisplay.innerText = 'Angle drawn. Value: ' + measurements[measurements.length - 1].value; 
                    currentDrawing = null;
                    magnifierDiv.style.display = 'none';
                    mode = 'pan'; // Reset mode
                    updateModeButtons();
                    renderMeasurementsList();
                    canvasContainer.classList.remove('drawing-mode');
                    saveState(); // Save state after completing angle drawing
                    return; // Exit to prevent further processing as measurement is complete
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'circle') {
                if (!currentDrawing) {
                    currentDrawing = { type: 'circle', points: [{ x, y }] }; // First point (center)
                    outputDisplay.innerText = '1: Circle center. 2: Radius point.'; 
                } else if (currentDrawing.points.length === 1) {
                    currentDrawing.points.push({ x, y }); // Second point (radius point)
                    const [center, radiusPoint] = currentDrawing.points;
                    const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                    const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                    const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit); // Correct circle area
                    const areaShotok = areaSqFt / 435.6;


                    measurements.push({
                        id: Date.now() + '-circle',
                        type: 'circle',
                        points: currentDrawing.points,
                        radius: radius / scaleFactorPixelsPerUnit, // Radius in feet
                        value: `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`,
                        areaSqFt: areaSqFt, // Store numeric value
                        areaShotok: areaShotok // Store numeric value
                    });
                    outputDisplay.innerText = 'Circle drawn. ' + measurements[measurements.length - 1].value; 
                    currentDrawing = null;
                    magnifierDiv.style.display = 'none';
                    mode = 'pan'; // Reset mode
                    updateModeButtons();
                    renderMeasurementsList();
                    canvasContainer.classList.remove('drawing-mode');
                    saveState(); // Save state after completing circle drawing
                    return; // Exit to prevent further processing as measurement is complete
                }
                magnifierDiv.style.display = 'block';
            } else if (mode === 'text') {
                const textInput = prompt("Enter text for the note:"); 
                if (textInput !== null && textInput.trim() !== '') {
                    measurements.push({
                        id: Date.now() + '-text',
                        type: 'text',
                        points: [{ x, y }],
                        text: textInput.trim()
                    });
                    outputDisplay.innerText = 'Text note added.'; 
                    renderMeasurementsList();
                    saveState(); // Save state after completing text drawing
                } else {
                    outputDisplay.innerText = 'Text note cancelled.'; 
                }
                magnifierDiv.style.display = 'none';
                mode = 'pan'; // Reset mode after placing text
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                return;
            } else if (mode === 'counter') {
                measurements.push({
                    id: Date.now() + '-counter',
                    type: 'counter',
                    points: [{ x, y }],
                    count: counterValue++ // Use and increment global counter
                });
                outputDisplay.innerText = `Counter ${counterValue - 1} added.`; 
                renderMeasurementsList();
                magnifierDiv.style.display = 'none';
                mode = 'pan'; // Reset mode after placing counter
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                saveState(); // Save state after completing counter drawing
                return;
            } else if (mode === 'freehand') {
                currentDrawing = { type: 'freehand', points: [{ x, y }] };
                outputDisplay.innerText = 'Click and drag to draw freehand.'; 
                magnifierDiv.style.display = 'block';
            }

            // Check for point selection for editing existing measurements (only in pan mode or if no drawing in progress)
            // If in calibrate mode AND we have 2 points, also allow selection of the points in `currentDrawing`.
            if (mode === 'pan' || (!currentDrawing && mode !== 'calibrate') || (currentDrawing && currentDrawing.type === 'calibrate' && currentDrawing.points.length === 2)) {
                selectedPoint = null; // Reset
                
                // Check currentDrawing points for calibration line editing
                if (mode === 'calibrate' && currentDrawing && currentDrawing.points.length === 2) {
                    for (let pIdx = 0; pIdx < currentDrawing.points.length; pIdx++) {
                        const p = currentDrawing.points[pIdx];
                        const screenP = getScreenCoords(p.x, p.y);
                        const effectiveHitRadius = HIT_RADIUS_BASE;
                        if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                            selectedPoint = {
                                measurementIndex: -1, // Indicates currentDrawing
                                pointIndex: pIdx,
                                type: 'calibrate',
                                originalX: p.x, // Store original canvas coords of the selected point
                                originalY: p.y
                            };
                            magnifierDiv.style.display = 'block';
                            return; // Stop checking after finding one
                        }
                    }
                }

                // Check existing measurements
                for (const m of measurements) {
                    if (m.type === 'text' || m.type === 'counter') {
                        const p = m.points[0];
                        const screenP = getScreenCoords(p.x, p.y);
                        const effectiveHitRadius = HIT_RADIUS_BASE * 2;
                        if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                            selectedPoint = {
                                measurementIndex: measurements.indexOf(m),
                                pointIndex: 0,
                                type: m.type,
                                originalX: p.x,
                                originalY: p.y
                            };
                            magnifierDiv.style.display = 'block';
                            return;
                        }
                    } else if (m.type === 'rectangle') {
                        const [p1, p2] = m.points;
                        // Calculate the four corners from the current defining points
                        const corners = [
                            { x: p1.x, y: p1.y, cornerType: 'tl' }, // Top-Left from p1
                            { x: p2.x, y: p1.y, cornerType: 'tr' }, // Top-Right (derived)
                            { x: p2.x, y: p2.y, cornerType: 'br' }, // Bottom-Right from p2
                            { x: p1.x, y: p2.y, cornerType: 'bl' }  // Bottom-Left (derived)
                        ];
                        for (let i = 0; i < corners.length; i++) {
                            const corner = corners[i];
                            const screenP = getScreenCoords(corner.x, corner.y);
                            const effectiveHitRadius = HIT_RADIUS_BASE;
                            if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                                selectedPoint = {
                                    measurementIndex: measurements.indexOf(m),
                                    pointIndex: i, // This index corresponds to the `corners` array above
                                    type: 'rectangle',
                                    cornerType: corner.cornerType,
                                    originalP1: { x: p1.x, y: p1.y }, // Store original defining points of the rectangle
                                    originalP2: { x: p2.x, y: p2.y },
                                    originalX: corner.x, // Store the exact clicked corner's original canvas X
                                    originalY: corner.y  // Store the exact clicked corner's original canvas Y
                                };
                                console.log("Selected Rectangle Corner:", selectedPoint); // Added debug log
                                magnifierDiv.style.display = 'block';
                                return;
                            }
                        }
                    } else if (m.type !== 'freehand') { // For other geometric shapes (excluding freehand)
                        for (let pIdx = 0; pIdx < m.points.length; pIdx++) {
                            const p = m.points[pIdx];
                            const screenP = getScreenCoords(p.x, p.y);
                            const effectiveHitRadius = HIT_RADIUS_BASE;
                            if (Math.hypot(e.clientX - (mainCanvas.getBoundingClientRect().left + screenP.x), e.clientY - (mainCanvas.getBoundingClientRect().top + screenP.y)) < effectiveHitRadius) {
                                selectedPoint = {
                                    measurementIndex: measurements.indexOf(m),
                                    pointIndex: pIdx,
                                    type: m.type,
                                    originalX: p.x,
                                    originalY: p.y
                                };
                                magnifierDiv.style.display = 'block';
                                return;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Handles pointer move events on the main canvas.
         * Updates pan, draws temporary lines/shapes, and updates magnifier content.
         * @param {PointerEvent} e - The pointermove event object.
         */
        function handlePointerMove(e) {
            lastPointerClientX = e.clientX;
            lastPointerClientY = e.clientY;

            // Update magnifier's internal state for redraw (its position is fixed by CSS)
            // The redraw function will use these updated clientX/Y to determine what part of the canvas to magnify.

            // Get canvas coordinates, potentially snapped to existing points
            const { x: currentCanvasX, y: currentCanvasY } = (mode !== 'pan' || selectedPoint) ? getSnappedCanvasCoords(e.clientX, e.clientY) : getCanvasCoords(e.clientX, e.clientY);

            if (selectedPoint) {
                // If a point of an existing measurement or currentDrawing is selected for editing
                if (selectedPoint.measurementIndex !== -1) { // Editing an existing measurement
                    const meas = measurements[selectedPoint.measurementIndex];
                    const dx = currentCanvasX - selectedPoint.originalX; // Delta X from original clicked point
                    const dy = currentCanvasY - selectedPoint.originalY; // Delta Y from original clicked point

                    if (selectedPoint.type === 'line' || selectedPoint.type === 'calibration') {
                        meas.points[selectedPoint.pointIndex] = { x: selectedPoint.originalX + dx, y: selectedPoint.originalY + dy };
                        if (selectedPoint.type === 'line') {
                            meas.value = calculateLineLength(meas.points[0], meas.points[1]);
                        }
                    } else if (selectedPoint.type === 'rectangle') {
                        let newP1 = { x: selectedPoint.originalP1.x, y: selectedPoint.originalP1.y };
                        let newP2 = { x: selectedPoint.originalP2.x, y: selectedPoint.originalP2.y };

                        switch (selectedPoint.cornerType) {
                            case 'tl': // Top-Left is dragged: update newP1 directly
                                newP1.x = selectedPoint.originalP1.x + dx;
                                newP1.y = selectedPoint.originalP1.y + dy;
                                break;
                            case 'tr': // Top-Right is dragged: update newP1.y and newP2.x
                                newP1.y = selectedPoint.originalP1.y + dy;
                                newP2.x = selectedPoint.originalP2.x + dx;
                                break;
                            case 'br': // Bottom-Right is dragged: update newP2 directly
                                newP2.x = selectedPoint.originalP2.x + dx;
                                newP2.y = selectedPoint.originalP2.y + dy;
                                break;
                            case 'bl': // Bottom-Left is dragged: update newP1.x and newP2.y
                                newP1.x = selectedPoint.originalP1.x + dx;
                                newP2.y = selectedPoint.originalP2.y + dy;
                                break;
                        }

                        // Ensure p1 is always top-left and p2 is always bottom-right for calculation consistency
                        // This handles cases where dragging inverts the rectangle
                        meas.points[0] = { x: Math.min(newP1.x, newP2.x), y: Math.min(newP1.y, newP2.y) };
                        meas.points[1] = { x: Math.max(newP1.x, newP2.x), y: Math.max(newP1.y, newP2.y) };


                        const areaResult = calculateRectangleArea(meas.points[0], meas.points[1]);
                        meas.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                        meas.areaSqFt = areaResult.sqFt;
                        meas.areaShotok = areaResult.shotok;
                    } else if (selectedPoint.type === 'polygon' || selectedPoint.type === 'angle' || selectedPoint.type === 'circle') {
                        meas.points[selectedPoint.pointIndex] = { x: selectedPoint.originalX + dx, y: selectedPoint.originalY + dy };
                        if (selectedPoint.type === 'polygon') {
                            const areaResult = calculatePolygonArea(meas.points);
                            meas.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                            meas.areaSqFt = areaResult.sqFt;
                            meas.areaShotok = areaResult.shotok;
                        } else if (selectedPoint.type === 'angle') {
                            const [p1, p2, p3] = meas.points;
                            meas.value = calculateAngle(p1, p2, p3);
                        } else if (selectedPoint.type === 'circle') {
                            const [center, radiusPoint] = meas.points;
                            const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                            const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                            const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                            const areaShotok = areaSqFt / 435.6;
                            meas.radius = radius / scaleFactorPixelsPerUnit;
                            meas.value = `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
                            meas.areaSqFt = areaSqFt; // Store numeric value
                            meas.areaShotok = areaShotok; // Store numeric value
                        }
                    } else if (selectedPoint.type === 'text' || selectedPoint.type === 'counter') {
                        meas.points[0] = { x: selectedPoint.originalX + dx, y: selectedPoint.originalY + dy };
                    } 
                } else if (selectedPoint.measurementIndex === -1 && selectedPoint.type === 'calibrate') {
                    // Editing a point of the temporary currentDrawing calibration line
                    const dx = currentCanvasX - selectedPoint.originalX; // Delta X from original clicked point
                    const dy = currentCanvasY - selectedPoint.originalY; // Delta Y from original clicked point
                    currentDrawing.points[selectedPoint.pointIndex] = { x: selectedPoint.originalX + dx, y: selectedPoint.originalY + dy };
                    outputDisplay.innerText = 'Adjusting calibration line...'; 
                }
                renderMeasurementsList(); // Update list after editing
            } else if (mode === 'pan' && isDragging) {
                // If in pan mode and dragging, update the pan offset
                pan.x += (e.clientX - startPoint.x);
                pan.y += (e.clientY - startPoint.y);
                startPoint.x = e.clientX;
                startPoint.y = e.clientY;
            } else if (currentDrawing && isDragging && (mode === 'line' || mode === 'rectangle' || mode === 'freehand')) { 
                // For drag-to-draw tools (line, rectangle, freehand), update the second point or add points
                if (mode === 'line' || mode === 'rectangle') {
                    currentDrawing.points[1] = { x: currentCanvasX, y: currentCanvasY };
                } else if (mode === 'freehand') {
                    currentDrawing.points.push({ x: currentCanvasX, y: currentCanvasY });
                }
            } 
            // For multi-click drawing modes (polygon, angle, circle, calibrate with 1 point),
            // temporary lines/shapes are drawn in redraw based on `lastPointerClientX/Y`
            // and `currentDrawing` points. No direct modification to `currentDrawing.points` needed here on move.
        }

        /**
         * Handles pointer up (mouse release or touch end) events on the main canvas.
         * Finalizes drawings or releases selected points.
         */
        function handlePointerUp() {
            isDragging = false;
            
            // If we were dragging a calibration point, clear the temporary `selectedPoint` and `currentDrawing`.
            // The actual calibration is confirmed via the button.
            if (selectedPoint && selectedPoint.type === 'calibrate' && selectedPoint.measurementIndex === -1) {
                // Do not clear currentDrawing here. It stays until confirmed or cancelled.
                // Re-set selectedPoint to null.
                selectedPoint = null;
                outputDisplay.innerText = 'Calibration line adjusted. Click "Confirm" to finalize or "Calibrate" to redraw.'; 
            } else {
                selectedPoint = null; // Clear selected point after release for other modes
            }

            magnifierDiv.style.display = 'none'; // Deactivate magnifier on pointer up

            // Finalize drawing for drag-to-draw tools (line, rectangle, freehand)
            if (currentDrawing && (mode === 'line' || mode === 'rectangle' || mode === 'freehand')) {
                if (mode === 'line') {
                    const line = {
                        id: Date.now() + '-line',
                        type: 'line',
                        points: currentDrawing.points,
                        value: calculateLineLength(currentDrawing.points[0], currentDrawing.points[1])
                    };
                    measurements.push(line);
                    outputDisplay.innerText = 'Line drawn. Length: ' + line.value; 
                } else if (mode === 'rectangle') {
                    const areaResult = calculateRectangleArea(currentDrawing.points[0], currentDrawing.points[1]);
                    const rect = {
                        id: Date.now() + '-rect',
                        type: 'rectangle',
                        points: currentDrawing.points,
                        value: `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`,
                        areaSqFt: areaResult.sqFt,
                        areaShotok: areaResult.shotok
                    };
                    measurements.push(rect);
                    outputDisplay.innerText = 'Rectangle drawn. Area: ' + rect.value; 
                } else if (mode === 'freehand') {
                    if (currentDrawing.points.length > 1) { // Only save if more than one point
                        let totalLength = 0;
                        for(let i = 0; i < currentDrawing.points.length - 1; i++) {
                            const p1 = currentDrawing.points[i];
                            const p2 = currentDrawing.points[i+1];
                            totalLength += Math.hypot(p2.x - p1.x, p2.y - p1.y);
                        }
                        const lengthInFeet = totalLength / scaleFactorPixelsPerUnit;
                        const lengthInLinks = lengthInFeet / 0.66;

                        measurements.push({
                            id: Date.now() + '-freehand',
                            type: 'freehand',
                            points: currentDrawing.points,
                            value: `${lengthInFeet.toFixed(2)} ft / ${lengthInLinks.toFixed(2)} links`
                        });
                        outputDisplay.innerText = 'Freehand drawing added. Total Length: ' + measurements[measurements.length - 1].value; 
                    } else {
                        outputDisplay.innerText = 'Freehand drawing cancelled (too short).'; 
                    }
                }
                currentDrawing = null; // Clear current drawing for drag-to-draw tools
                renderMeasurementsList(); // Update list after new measurement
                saveState(); // Save state after completing a drawing action
            }

            // Revert to pan mode if a drawing action (excluding multi-click modes like polygon, angle, circle, calibrate) is completed.
            // For calibrate, we explicitly wait for confirmCalibrationBtn click.
            if (mode !== 'polygon' && mode !== 'angle' && mode !== 'circle' && mode !== 'calibrate') {
                mode = 'pan'; // Reset to pan mode
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
            }
        }

        /**
         * Handles double-click events on the main canvas.
         * Used to finalize polygon drawing.
         * @param {MouseEvent} e - The dblclick event object.
         */
        function handleDoubleClick(e) {
            e.preventDefault();
            if (mode === 'polygon' && currentDrawing && currentDrawing.points.length >= 3) {
                const areaResult = calculatePolygonArea(currentDrawing.points);
                const polygon = {
                    id: Date.now() + '-poly',
                    type: 'polygon',
                    points: currentDrawing.points,
                    closed: true, // Mark as closed
                    value: `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`,
                    areaSqFt: areaResult.sqFt,
                    areaShotok: areaResult.shotok
                };
                measurements.push(polygon);
                outputDisplay.innerText = 'Polygon drawn. Area: ' + polygon.value; 
                currentDrawing = null;
                renderMeasurementsList(); // Update list after new measurement
                mode = 'pan'; // Reset to pan mode
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
                saveState(); // Save state after completing polygon drawing
            }
            magnifierDiv.style.display = 'none'; // Deactivate magnifier on double click for polygon
        }

        /**
         * Handles mouse wheel events for zooming.
         * Zooms in/out centered on the mouse pointer.
         * @param {WheelEvent} e - The wheel event object.
         */
        function handleWheel(e) {
            e.preventDefault(); // Prevent default browser scroll/zoom
            const zoomAmount = e.deltaY < 0 ? 1.1 : 0.9; // Determine zoom direction and factor

            const rect = mainCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; // Mouse X relative to canvas
            const mouseY = e.clientY - rect.top; // Mouse Y relative to canvas

            // Calculate mouse position in canvas coordinates BEFORE zooming
            const canvasX = (mouseX - pan.x) / zoom;
            const canvasY = (mouseY - pan.y) / zoom;

            zoom *= zoomAmount; // Apply new zoom level

            // Adjust pan to keep the mouse point fixed on the canvas
            pan.x = mouseX - canvasX * zoom;
            pan.y = mouseY - canvasY * zoom;
        }

        // Variables for touch pinch-to-zoom
        let lastTouchDist = null;

        /**
         * Handles touch start events for panning and pinch-to-zoom.
         * @param {TouchEvent} e - The touchstart event object.
         */
        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                // If two fingers, initiate pinch-to-zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[0].clientY; 
                lastTouchDist = Math.hypot(dx, dy); // Store initial distance between fingers
                magnifierDiv.style.display = 'none'; // Hide magnifier during multi-touch
                currentDrawing = null; // Clear any partial drawing if multi-touch starts
                mode = 'pan'; // Force pan mode on multi-touch
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
            } else if (e.touches.length === 1) {
                // If one finger, treat as a single pointer down event (for drawing/panning)
                handlePointerDown(e.touches[0]);
            }
        }

        /**
         * Handles touch move events for panning and pinch-to-zoom.
         * @param {TouchEvent} e - The touchmove event object.
         */
        function handleTouchMove(e) {
            // Update last pointer client coordinates for magnifier, even during touch
            if (e.touches.length === 1 && magnifierDiv.style.display === 'block') {
                lastPointerClientX = e.touches[0].clientX;
                lastPointerClientY = e.touches[0].clientY;
            }

            if (e.touches.length === 2) {
                // If two fingers, perform pinch-to-zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const newDist = Math.hypot(dx, dy); // Current distance between fingers

                if (lastTouchDist) {
                    const zoomAmount = newDist / lastTouchDist; // Calculate zoom factor
                    const rect = mainCanvas.getBoundingClientRect();
                    // Calculate center of the two touches
                    const touchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const touchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                    // Convert touch center to canvas coordinates
                    const canvasX = (touchX - rect.left - pan.x) / zoom;
                    const canvasY = (touchY - rect.y - pan.y) / zoom;

                    zoom *= zoomAmount; // Apply new zoom
                    // Adjust pan to keep the pinch center fixed
                    pan.x = touchX - rect.left - canvasX * zoom;
                    pan.y = touchY - rect.y - canvasY * zoom;
                }
                lastTouchDist = newDist; // Update last distance for next move
                e.preventDefault(); // Prevent default browser gestures (e.g., scrolling)
            } else if (e.touches.length === 1) {
                // If one finger, treat as a single pointer move event
                handlePointerMove(e.touches[0]);
            }
        }

        /**
         * Handles touch end events.
         * Resets touch tracking variables.
         * @param {TouchEvent} e - The touchend event object.
         */
        function handleTouchEnd(e) {
            lastTouchDist = null; // Clear pinch-to-zoom state
            if (e.touches.length === 0) {
                // If all fingers are lifted, treat as a single pointer up event
                handlePointerUp();
            }
        }

        // --- File Loading Logic ---

        /**
         * Loads an image or PDF file onto the canvas.
         * Resets canvas state and measurements before loading.
         * For PDFs, it renders the first page to a high-resolution offscreen canvas,
         * then converts that to an image to be drawn on the main canvas.
         * This approach ensures clarity during zoom/pan while keeping `redraw` logic simple.
         * @param {File} file - The file object to load.
         */
        let currentPdfPage = null; // To store the PDF page for direct rendering

        async function loadFile(file) {
            if (!file) return;

            // Reset canvas state and measurements
            imgLoaded = false;
            img.src = ''; // Clear previous image or PDF dataURL
            measurements = [];
            measurementHistory = []; // Clear history on new file load
            historyPointer = -1; // Reset history pointer
            updateUndoRedoButtons(); // Update button state
            renderMeasurementsList();
            outputDisplay.innerText = 'Loading file...'; 
            mode = 'pan'; // Reset mode to pan
            updateModeButtons();
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair
            confirmCalibrationBtn.style.display = 'none'; // Hide confirm button on new file load
            currentPdfPage = null; // Clear previous PDF page reference
            
            // Set initial scale parameters from UI inputs
            PIXELS_PER_INCH_CURRENT = parseFloat(dpiInput.value);
            FEET_PER_INCH_CURRENT = parseFloat(feetPerInchInput.value);
            scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT;


            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    img.onload = () => {
                        imgLoaded = true;
                        // Center image on load
                        pan = {
                            x: (mainCanvas.clientWidth - img.width * zoom) / 2,
                            y: (mainCanvas.clientHeight - img.height * zoom) / 2,
                        };
                        zoom = 1; // Reset zoom
                        outputDisplay.innerText = `Image loaded. Scale: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} feet. Start measuring now.`; 
                        redraw(); // Force a redraw
                        saveState(); // Save initial state to history
                    };
                    img.src = event.target.result; // Set image source from file
                };
                reader.readAsDataURL(file); // Read image as Data URL
            } else if (file.type === 'application/pdf') {
                outputDisplay.innerText = 'Loading PDF... Please wait.'; 
                const reader = new FileReader();
                reader.onload = function(event) {
                    const pdfData = new Uint8Array(event.target.result);
                    
                    pdfjsLib.getDocument({ data: pdfData }).promise.then(function(pdf) {
                        outputDisplay.innerText = `PDF loaded (${pdf.numPages} pages). Rendering page 1...`; 
                        return pdf.getPage(1);
                    }).then(function(page) {
                        currentPdfPage = page; // Store the page object for resize handling
                        const desiredPpi = parseFloat(dpiInput.value) || 300;
                        const scale = desiredPpi / 72; // PDF native is 72 PPI
                        const viewport = page.getViewport({ scale: scale });

                        const tempCanvas = document.createElement('canvas'); 
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = viewport.width;
                        tempCanvas.height = viewport.height;

                        const renderContext = { canvasContext: tempCtx, viewport: viewport };
                        return page.render(renderContext).promise.then(() => {
                            // After rendering is complete on tempCanvas, update img.src
                            img.onload = () => {
                                imgLoaded = true;
                                pan = {
                                    x: (mainCanvas.clientWidth - img.width * zoom) / 2,
                                    y: (mainCanvas.clientHeight - img.height * zoom) / 2,
                                };
                                zoom = 1;
                                outputDisplay.innerText = `PDF page 1 loaded as image. Scale: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} feet. Start measuring now.`; 
                                redraw();
                                saveState(); // Save initial state to history
                            };
                            // Use the tempCanvas directly for toDataURL
                            img.src = tempCanvas.toDataURL('image/png');
                            tempCanvas.remove(); // Clean up the temporary canvas
                        });
                    }).catch(err => {
                        outputDisplay.innerText = 'Error loading PDF: ' + err.message + '. Ensure the file is valid and you are serving this HTML file from a web server (e.g., http://localhost) due to browser security restrictions on local files.'; 
                        console.error('PDF.js error:', err);
                    });
                };
                reader.readAsArrayBuffer(file); // Read PDF as ArrayBuffer
            } else {
                outputDisplay.innerText = 'Unsupported file type. Please load an image or PDF file.'; 
            }
        }


        // Event listener for image/PDF file input change
        imageLoader.addEventListener('change', (e) => {
            loadFile(e.target.files[0]);
        });

        // --- Drag and Drop functionality for loading files ---
        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); // Prevent default dragover behavior
            e.stopPropagation(); // Stop event propagation
            e.dataTransfer.dropEffect = 'copy'; // Visual feedback for drop operation
            canvasContainer.style.borderColor = '#3b82f6'; // Highlight drag area
        });

        canvasContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.style.borderColor = 'transparent'; // Reset border on drag leave
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvasContainer.style.borderColor = 'transparent'; // Reset border on drop
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                loadFile(e.dataTransfer.files[0]); // Load the dropped file
            }
        });


        // Event listeners for DPI and Feet/Inch input changes
        dpiInput.addEventListener('input', () => {
            PIXELS_PER_INCH_CURRENT = parseFloat(dpiInput.value);
            if (FEET_PER_INCH_CURRENT > 0) {
                scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT;
                outputDisplay.innerText = `Scale updated: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} feet.`; 
                // Re-calculate all measurements based on new scale
                measurements.forEach(m => {
                    if (m.type === 'line') {
                        m.value = calculateLineLength(m.points[0], m.points[1]);
                    } else if (m.type === 'rectangle') {
                        const areaResult = calculateRectangleArea(m.points[0], m.points[1]);
                        m.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                        m.areaSqFt = areaResult.sqFt;
                        m.areaShotok = areaResult.shotok;
                    } else if (m.type === 'polygon') {
                        const areaResult = calculatePolygonArea(m.points);
                        m.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                        m.areaSqFt = areaResult.sqFt;
                        m.areaShotok = areaResult.shotok;
                    } else if (m.type === 'angle') {
                        const [p1, p2, p3] = m.points;
                        m.value = calculateAngle(p1, p2, p3);
                    } else if (m.type === 'circle') {
                        const [center, radiusPoint] = m.points;
                        const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                        const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                        const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                        const areaShotok = areaSqFt / 435.6;
                        m.radius = radius / scaleFactorPixelsPerUnit;
                        m.value = `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
                        m.areaSqFt = areaSqFt; // Store numeric value
                        m.areaShotok = areaShotok; // Store numeric value
                    } else if (m.type === 'freehand') {
                        let totalLength = 0;
                        for(let i = 0; i < m.points.length - 1; i++) {
                            const p1 = m.points[i];
                            const p2 = m.points[i+1];
                            totalLength += Math.hypot(p2.x - p1.x, p2.y - p1.y);
                        }
                        const lengthInFeet = totalLength / scaleFactorPixelsPerUnit;
                        const lengthInLinks = lengthInFeet / 0.66;
                        m.value = `${lengthInFeet.toFixed(2)} ft / ${lengthInLinks.toFixed(2)} links`;
                    }
                });
                renderMeasurementsList();
            } else {
                outputDisplay.innerText = `Error: Feet/Inch cannot be zero.`; 
            }
            redraw(); // Redraw canvas to reflect potential scale changes
        });

        feetPerInchInput.addEventListener('input', () => {
            FEET_PER_INCH_CURRENT = parseFloat(feetPerInchInput.value);
            if (FEET_PER_INCH_CURRENT > 0) {
                scaleFactorPixelsPerUnit = PIXELS_PER_INCH_CURRENT / FEET_PER_INCH_CURRENT;
                outputDisplay.innerText = `Scale updated: ${PIXELS_PER_INCH_CURRENT} DPI & 1 inch = ${FEET_PER_INCH_CURRENT} feet.`; 
                // Re-calculate all measurements based on new scale
                measurements.forEach(m => {
                    if (m.type === 'line') {
                        m.value = calculateLineLength(m.points[0], m.points[1]);
                    } else if (m.type === 'rectangle') {
                        const areaResult = calculateRectangleArea(m.points[0], m.points[1]);
                        m.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                        m.areaSqFt = areaResult.sqFt;
                        m.areaShotok = areaResult.shotok;
                    } else if (m.type === 'polygon') {
                        const areaResult = calculatePolygonArea(m.points);
                        m.value = `${areaResult.sqFt.toFixed(2)} sq ft / ${areaResult.shotok.toFixed(4)} shotok`;
                        m.areaSqFt = areaResult.sqFt;
                        m.areaShotok = areaResult.shotok;
                    } else if (m.type === 'angle') {
                        const [p1, p2, p3] = m.points;
                        m.value = calculateAngle(p1, p2, p3);
                    } else if (m.type === 'circle') {
                        const [center, radiusPoint] = m.points;
                        const radius = Math.hypot(radiusPoint.x - center.x, radiusPoint.y - center.y);
                        const circumference = 2 * Math.PI * radius / scaleFactorPixelsPerUnit;
                        const areaSqFt = Math.PI * (radius / scaleFactorPixelsPerUnit) * (radius / scaleFactorPixelsPerUnit);
                        const areaShotok = areaSqFt / 435.6;
                        m.radius = radius / scaleFactorPixelsPerUnit;
                        m.value = `Circ: ${circumference.toFixed(2)} ft, Area: ${areaSqFt.toFixed(2)} sq ft / ${areaShotok.toFixed(4)} shotok`;
                        m.areaSqFt = areaSqFt; // Store numeric value
                        m.areaShotok = areaShotok; // Store numeric value
                    } else if (m.type === 'freehand') {
                        let totalLength = 0;
                        for(let i = 0; i < m.points.length - 1; i++) {
                            const p1 = m.points[i];
                            const p2 = m.points[i+1];
                            totalLength += Math.hypot(p2.x - p1.x, p2.y - p1.y);
                        }
                        const lengthInFeet = totalLength / scaleFactorPixelsPerUnit;
                        const lengthInLinks = lengthInFeet / 0.66;
                        m.value = `${lengthInFeet.toFixed(2)} ft / ${lengthInLinks.toFixed(2)} links`;
                    }
                });
                renderMeasurementsList();
            } else {
                outputDisplay.innerText = `Error: Feet/Inch cannot be zero.`; 
            }
            redraw(); // Redraw canvas to reflect potential scale changes
        });

        // Event listener for "Calibrate Scale" button
        calibrateScaleBtn.addEventListener('click', () => {
            if (!imgLoaded) {
                outputDisplay.innerText = 'Please load an image or PDF first.'; 
                return;
            }
            // If already in calibration mode, clicking again cancels it
            if (mode === 'calibrate') {
                mode = 'pan';
                currentDrawing = null; // Clear current calibration line
                confirmCalibrationBtn.style.display = 'none'; // Hide confirm button
                outputDisplay.innerText = 'Calibration cancelled.'; 
                updateModeButtons();
                canvasContainer.classList.remove('drawing-mode');
                return;
            }

            mode = 'calibrate'; // Set mode to calibrate
            currentDrawing = null; // Clear any existing temporary drawing
            outputDisplay.innerText = 'Click the first point for calibration.'; 
            updateModeButtons(); // Update button highlighting
            canvasContainer.classList.add('drawing-mode'); // Show crosshair cursor
            confirmCalibrationBtn.style.display = 'none'; // Ensure confirm button is hidden initially
        });

        // Event listener for "Confirm Calibration" button
        confirmCalibrationBtn.addEventListener('click', () => {
            // Only proceed if in calibrate mode and a two-point line has been drawn
            if (mode === 'calibrate' && currentDrawing && currentDrawing.points.length === 2) {
                const [p1, p2] = currentDrawing.points;
                const pixelDistance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                
                // Prompt user for the real-world distance
                let realWorldLength = parseFloat(prompt("Enter the real-world distance (in feet) between the two points:")); 
                
                if (!isNaN(realWorldLength) && realWorldLength > 0) {
                    // Recalculate scale factor
                    scaleFactorPixelsPerUnit = pixelDistance / realWorldLength;
                    // Update DPI input to reflect the new calibration based on the existing Feet/Inch
                    PIXELS_PER_INCH_CURRENT = scaleFactorPixelsPerUnit * FEET_PER_INCH_CURRENT;
                    dpiInput.value = PIXELS_PER_INCH_CURRENT.toFixed(2);

                    // Add calibration as a measurement
                    measurements.push({
                        id: Date.now() + '-calibration',
                        type: 'calibration',
                        points: currentDrawing.points,
                        value: `${realWorldLength.toFixed(2)} ft (1 inch = ${FEET_PER_INCH_CURRENT.toFixed(2)} ft, DPI = ${PIXELS_PER_INCH_CURRENT.toFixed(2)}).` 
                    });
                    outputDisplay.innerText = `Scale calibrated! 1 inch = ${FEET_PER_INCH_CURRENT.toFixed(2)} feet (DPI: ${PIXELS_PER_INCH_CURRENT.toFixed(2)}).`; 
                    saveState(); // Save state after calibration
                    
                } else {
                    outputDisplay.innerText = 'Invalid length entered. Calibration cancelled.'; 
                }
            } else {
                outputDisplay.innerText = 'Please draw a calibration line first (two clicks).'; 
            }
            currentDrawing = null; // Clear current drawing after confirmation attempt
            confirmCalibrationBtn.style.display = 'none'; // Hide confirm button
            mode = 'pan'; // Reset mode to pan
            updateModeButtons(); // Update button highlighting
            renderMeasurementsList(); // Update measurements list
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair cursor
        });


        // Event listener for "Export CSV" button
        exportCsvBtn.addEventListener('click', () => {
            if (measurements.length === 0) {
                outputDisplay.innerText = 'No measurements to export.'; 
                return;
            }

            // Prepare CSV header and content
            let csvContent = "Type,Value,Text,Count,Radius(ft),AreaSqFt,AreaShotok,Points\n"; // Added AreaSqFt, AreaShotok
            measurements.forEach(m => {
                const type = m.type;
                const value = m.value || '';
                const text = m.text ? `"${m.text.replace(/"/g, '""')}"` : ''; // Handle quotes in text
                const count = m.count !== undefined ? m.count : '';
                const radius = m.radius !== undefined ? m.radius.toFixed(2) : '';
                const areaSqFt = m.areaSqFt !== undefined ? m.areaSqFt.toFixed(2) : ''; // New
                const areaShotok = m.areaShotok !== undefined ? m.areaShotok.toFixed(4) : ''; // New
                const points = m.points.map(p => `(${p.x.toFixed(2)},${p.y.toFixed(2)})`).join(';');
                csvContent += `${type},"${value}",${text},"${count}","${radius}","${areaSqFt}","${areaShotok}","${points}"\n`;
            });

            // Create a Blob and download as CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'measurements.csv'); // File name for download
            link.click(); // Programmatically click the link to trigger download
            outputDisplay.innerText = 'Measurements exported to CSV.'; 
        });

        // Event listeners for drawing tool buttons
        drawLineBtn.addEventListener('click', () => {
            mode = 'line';
            currentDrawing = null; 
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = 'Click and drag to draw a line.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawRectangleBtn.addEventListener('click', () => {
            mode = 'rectangle';
            currentDrawing = null; 
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = 'Click and drag to draw a rectangle.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawPolygonBtn.addEventListener('click', () => {
            mode = 'polygon';
            currentDrawing = { type: 'polygon', points: [], closed: false }; 
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = 'Click to add points for polygon. Double-click to finish.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawAngleBtn.addEventListener('click', () => {
            mode = 'angle';
            currentDrawing = null; 
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = '1: End of first arm. 2: Vertex. 3: End of second arm.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        drawCircleBtn.addEventListener('click', () => {
            mode = 'circle';
            currentDrawing = null; 
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = '1: Circle center. 2: Radius point.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        addTextBtn.addEventListener('click', () => {
            mode = 'text';
            currentDrawing = null;
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = 'Click on canvas to add a text note.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        addCounterBtn.addEventListener('click', () => {
            mode = 'counter';
            currentDrawing = null;
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = 'Click on canvas to add a counter.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });
        freehandBtn.addEventListener('click', () => {
            mode = 'freehand';
            currentDrawing = null;
            confirmCalibrationBtn.style.display = 'none'; 
            outputDisplay.innerText = 'Click and drag to draw freehand.'; 
            updateModeButtons();
            canvasContainer.classList.add('drawing-mode');
        });

        // Event listeners for style options (Line Width and Font Size)
        lineWidthInput.addEventListener('input', redraw);
        fontSizeInput.addEventListener('input', redraw);


        // Event listener for "Undo" button
        undoBtn.addEventListener('click', () => {
            if (historyPointer > 0) {
                loadState(historyPointer - 1);
                outputDisplay.innerText = 'Last change undone.'; 
            } else {
                outputDisplay.innerText = 'No changes to undo.'; 
            }
        });

        // Event listener for "Redo" button
        redoBtn.addEventListener('click', () => {
            if (historyPointer < measurementHistory.length - 1) {
                loadState(historyPointer + 1);
                outputDisplay.innerText = 'Last change redone.'; 
            } else {
                outputDisplay.innerText = 'No changes to redo.'; 
            }
        });

        // Event listener for "Reset All" button
        resetAllBtn.addEventListener('click', () => {
            measurements = []; // Clear all measurements
            zoom = 1; // Reset zoom level
            pan = { x: 0, y: 0 }; // Reset pan position
            imgLoaded = false; // Mark image/PDF as not loaded
            img.src = ''; // Clear image source
            currentPdfPage = null; // Clear PDF page reference
            outputDisplay.innerText = 'Canvas reset. Load an image or PDF and start measuring.'; 
            mode = 'pan'; // Reset mode to pan
            currentDrawing = null; // Clear any partial drawing
            counterValue = 1; // Reset counter
            measurementHistory = []; // Clear history on full reset
            historyPointer = -1; // Reset history pointer
            updateUndoRedoButtons(); // Update button state
            updateModeButtons(); // Update button highlighting
            renderMeasurementsList(); // Clear the measurements list in the sidebar
            canvasContainer.classList.remove('drawing-mode'); // Remove crosshair cursor
            confirmCalibrationBtn.style.display = 'none'; // Hide confirm button
        });

        // Event listener for deleting and editing individual measurements from the sidebar list
        measurementsListDiv.addEventListener('click', (e) => {
            // Check if a delete button was clicked
            if (e.target.tagName === 'BUTTON' && e.target.classList.contains('delete-btn')) {
                const indexToRemove = parseInt(e.target.dataset.index);
                if (indexToRemove >= 0 && indexToRemove < measurements.length) {
                    measurements.splice(indexToRemove, 1); // Remove the measurement from the array
                    outputDisplay.innerText = 'Measurement deleted.'; 
                    renderMeasurementsList(); // Re-render the list to update display
                    saveState(); // Save state after deletion
                }
            } else if (e.target.tagName === 'BUTTON' && e.target.classList.contains('edit-btn')) { // Check if an edit button was clicked
                const indexToEdit = parseInt(e.target.dataset.index);
                const measurementToEdit = measurements[indexToEdit];

                if (measurementToEdit && measurementToEdit.type === 'text') {
                    const newText = prompt("Edit text note:", measurementToEdit.text); 
                    if (newText !== null) {
                        measurementToEdit.text = newText.trim();
                        outputDisplay.innerText = 'Text note updated.'; 
                        renderMeasurementsList(); // Re-render the list to update display
                        redraw(); // Redraw canvas to reflect text change
                        saveState(); // Save state after edit
                    } else {
                        outputDisplay.innerText = 'Text note edit cancelled.'; 
                    }
                }
            }
        });

        /**
         * Updates the visual style (highlighting) of mode buttons based on the current active mode.
         */
        function updateModeButtons() {
            const allDrawButtons = [
                drawLineBtn, drawRectangleBtn, drawPolygonBtn,
                drawAngleBtn, drawCircleBtn, addTextBtn, addCounterBtn, freehandBtn,
                calibrateScaleBtn 
            ];
            allDrawButtons.forEach(btn => {
                // Remove active (600) classes and re-add default (500) classes
                btn.classList.remove(
                    'bg-green-600', 'bg-purple-600', 'bg-indigo-600',
                    'bg-pink-600', 'bg-orange-600', 'bg-teal-600', 'bg-cyan-600', 'bg-gray-600', 'bg-blue-600'
                );
                // Ensure default 500 class is present for non-active buttons
                if (btn.id.includes('Line')) btn.classList.add('bg-green-500');
                else if (btn.id.includes('Rectangle')) btn.classList.add('bg-purple-500');
                else if (btn.id.includes('Polygon')) btn.classList.add('bg-indigo-500');
                else if (btn.id.includes('Angle')) btn.classList.add('bg-pink-500');
                else if (btn.id.includes('Circle')) btn.classList.add('bg-orange-500');
                else if (btn.id.includes('Text')) btn.classList.add('bg-teal-500');
                else if (btn.id.includes('Counter')) btn.classList.add('bg-cyan-500');
                else if (btn.id.includes('Freehand')) btn.classList.add('bg-gray-500');
                else if (btn.id.includes('Calibrate')) btn.classList.add('bg-blue-500');
                else btn.classList.add('bg-gray-500'); // Fallback
            });

            // Highlight the currently active mode button
            const activeColor = {
                'pan': '', // No highlight for pan mode button
                'calibrate': 'bg-blue-600',
                'line': 'bg-green-600',
                'rectangle': 'bg-purple-600',
                'polygon': 'bg-indigo-600',
                'angle': 'bg-pink-600',
                'circle': 'bg-orange-600',
                'text': 'bg-teal-600',
                'counter': 'bg-cyan-600',
                'freehand': 'bg-gray-600'
            };
            if (mode !== 'pan') {
                let activeButton;
                if (mode === 'text') {
                    activeButton = addTextBtn;
                } else if (mode === 'counter') {
                    activeButton = addCounterBtn;
                } else if (mode === 'calibrate') {
                    activeButton = calibrateScaleBtn;
                } else if (mode === 'line') { // Specific handling for Line button
                    activeButton = drawLineBtn;
                } else if (mode === 'rectangle') { // Specific handling for Rectangle button
                    activeButton = drawRectangleBtn;
                } else if (mode === 'polygon') { // Specific handling for Polygon button
                    activeButton = drawPolygonBtn;
                } else if (mode === 'angle') { // Specific handling for Angle button
                    activeButton = drawAngleBtn;
                } else if (mode === 'circle') { // Specific handling for Circle button
                    activeButton = drawCircleBtn;
                } else if (mode === 'freehand') { // Specific handling for Freehand button
                    activeButton = freehandBtn;
                }
                
                if (activeButton) {
                    // Remove current 500 version and add the 600 version for highlighting
                    const baseClass = activeColor[mode].replace('600', '500');
                    if (activeButton.classList.contains(baseClass)) {
                        activeButton.classList.remove(baseClass);
                    }
                    activeButton.classList.add(activeColor[mode]);
                }
            }
        }

        // --- New Sidebar and Toolbar Collapse Logic ---

        // Sidebar Toggle
        sidebarToggleButton.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            // Toggle the correct Font Awesome icon classes
            const icon = sidebarToggleButton.querySelector('.fas');
            icon.classList.toggle('fa-chevron-left');
            icon.classList.toggle('fa-chevron-right');
            sidebarToggleButton.classList.toggle('rotated'); // For a smoother arrow rotation
            console.log('Sidebar toggled. Is collapsed:', sidebar.classList.contains('collapsed')); // Added debug log
        });

        // Toolbar Toggle
        toolbarToggleButton.addEventListener('click', () => {
            collapsibleToolbarContent.classList.toggle('collapsed');
            const icon = toolbarToggleButton.querySelector('.fas');
            const textSpan = toolbarToggleButton.querySelector('span');

            if (collapsibleToolbarContent.classList.contains('collapsed')) {
                icon.classList.replace('fa-chevron-up', 'fa-chevron-down');
                textSpan.textContent = 'More Tools';
            } else {
                icon.classList.replace('fa-chevron-down', 'fa-chevron-up');
                textSpan.textContent = 'Less Tools';
            }
        });


        // Attach main canvas event listeners for mouse/touch interactions
        mainCanvas.addEventListener('pointerdown', handlePointerDown);
        mainCanvas.addEventListener('pointermove', handlePointerMove);
        mainCanvas.addEventListener('pointerup', handlePointerUp);
        mainCanvas.addEventListener('wheel', handleWheel, { passive: false }); // Use passive: false to allow preventDefault
        mainCanvas.addEventListener('touchstart', handleTouchStart, { passive: false }); // Use passive: false for custom touch handling
        mainCanvas.addEventListener('touchmove', handleTouchMove, { passive: false }); // Use passive: false
        mainCanvas.addEventListener('touchend', handleTouchEnd);
        mainCanvas.addEventListener('dblclick', handleDoubleClick); // For polygon finalization

        // Handle window resize events to adjust canvas and content positioning
        window.addEventListener('resize', () => {
            if (imgLoaded) {
                // Adjust pan to keep the center of the image/PDF visible as much as possible
                // This recalculation helps maintain the view when the window resizes
                pan = {
                    x: (mainCanvas.clientWidth - (img.width * zoom)) / 2,
                    y: (mainCanvas.clientHeight - (img.height * zoom)) / 2,
                };
                 // If a PDF is loaded, re-render it to adapt to new canvas size for clarity
                 // This re-rendering ensures the PDF remains crisp on resize.
                if (currentPdfPage) {
                    // Recalculate rendering scale based on new canvas dimensions
                    const viewport = currentPdfPage.getViewport({ scale: 1 });
                    const desiredPpi = parseFloat(dpiInput.value) || 300;
                    const scale = desiredPpi / 72;
                    const renderViewport = currentPdfPage.getViewport({ scale: scale });

                    const offscreenCanvas = document.createElement('canvas');
                    const offscreenCtx = offscreenCanvas.getContext('2d');
                    offscreenCanvas.width = renderViewport.width;
                    offscreenCanvas.height = renderViewport.height;

                    const renderContext = {
                        canvasContext: offscreenCtx,
                        viewport: renderViewport,
                    };
                    currentPdfPage.render(renderContext).promise.then(() => {
                        img.src = offscreenCanvas.toDataURL('image/png'); // Update the main img object
                        offscreenCanvas.remove();
                        redraw(); // Request a full redraw after PDF re-render
                    });
                }
            }
            renderMeasurementsList(); // Re-render list
        });
        window.addEventListener('orientationchange', () => {
            // Similar logic for orientation change on mobile devices
            if (imgLoaded) {
                pan = {
                    x: (mainCanvas.clientWidth - (img.width * zoom)) / 2,
                    y: (mainCanvas.clientHeight - (img.height * zoom)) / 2,
                };
                 // If a PDF is loaded, re-render it to adapt to new canvas size for clarity
                if (currentPdfPage) {
                    const viewport = currentPdfPage.getViewport({ scale: 1 });
                    const desiredPpi = parseFloat(dpiInput.value) || 300;
                    const scale = desiredPpi / 72;
                    const renderViewport = currentPdfPage.getViewport({ scale: scale });

                    const offscreenCanvas = document.createElement('canvas');
                    const offscreenCtx = offscreenCanvas.getContext('2d');
                    offscreenCanvas.width = renderViewport.width;
                    offscreenCanvas.height = renderViewport.height;
                    
                    const renderContext = {
                        canvasContext: offscreenCtx,
                        viewport: renderViewport,
                    };
                    currentPdfPage.render(renderContext).promise.then(() => {
                        img.src = offscreenCanvas.toDataURL('image/png'); // Update the main img object
                        offscreenCanvas.remove();
                        redraw(); // Request a full redraw after PDF re-render
                    });
                }
            }
            renderMeasurementsList();
        });

        // Initial rendering of the measurement list when the page loads
        renderMeasurementsList();
        updateUndoRedoButtons(); // Initialize button states

        // Start the animation loop. This ensures continuous redrawing for dynamic elements.
        requestAnimationFrame(redraw);
    </script>
</body>
</html>
